const puppeteer = require('puppeteer');
const path = require('path');
const fs = require('fs');
const { HttpsProxyAgent } = require('https-proxy-agent');
const axios = require('axios');
const robot = require('robotjs');
const WebSocket = require('ws');
const wss = new WebSocket.Server({ port: 8080 });

// Đọc danh sách profile và proxy từ file
const readProfilesFromFile = () => {
    const filePath = path.join(__dirname, 'SelectedAllProfiles.txt');
    if (!fs.existsSync(filePath)) {
        console.error('File SelectedAllProfiles.txt không tồn tại.');
        process.exit(1);
    }

    const lines = fs.readFileSync(filePath, 'utf-8').split('\n').map(line => line.trim()).filter(Boolean);
    return lines.map(line => {
        const parts = line.split('|');
        if (parts.length < 2) {
            console.error(`Dòng không hợp lệ: "${line}"`);
            return null;
        }
        return { folderName: parts[0], proxy: parts[1] };
    }).filter(Boolean);
};

// Đảm bảo file tồn tại trước khi đọc
const readThreadCount = async () => {
    const filePath = path.join(__dirname, 'Theard.txt');
    await waitForFile(filePath);  // Đợi file tồn tại trước khi tiếp tục

    const threadCount = parseInt(fs.readFileSync(filePath, 'utf-8').trim(), 10);
    if (isNaN(threadCount) || threadCount <= 0) {
        console.error('Giá trị ThreadCount không hợp lệ.');
        process.exit(1);
    }

    return threadCount; // Trả về giá trị số luồng thực sự
};

// Đảm bảo waitForFile trả về một Promise
const waitForFile = (filePath) => {
    return new Promise((resolve, reject) => {
        const interval = setInterval(() => {
            if (fs.existsSync(filePath)) {
                clearInterval(interval);
                resolve();
            }
        }, 100);  // Kiểm tra mỗi 100ms
    });
};

// Đọc danh sách proxy từ file
const readProxiesFromFile = () => {
    const filePath = path.join(__dirname, 'proxy.txt');
    if (!fs.existsSync(filePath)) {
        console.error('File proxy.txt không tồn tại.');
        process.exit(1);
    }

    return fs.readFileSync(filePath, 'utf-8')
        .split('\n')
        .map(line => line.trim())
        .filter(Boolean)
        .map(proxy => {
            const regex = /^http:\/\/([^:]+):([^@]+)@([^:]+):(\d+)$/;
            const match = proxy.match(regex);
            if (!match) {
                console.error(`Proxy không hợp lệ: "${proxy}"`);
                return null;
            }
            const [, username, password, host, port] = match;
            return { username, password, host, port };
        })
        .filter(Boolean);
};

// Kiểm tra proxy
const checkProxy = async (proxy) => {
    try {
        const { username, password, host, port } = proxy;
        const agent = new HttpsProxyAgent(`http://${username}:${password}@${host}:${port}`);
        const response = await axios.get('https://httpbin.org/ip', { httpsAgent: agent });
        console.log('Proxy hoạt động:', response.data);
        return true;
    } catch (error) {
        console.error('Lỗi proxy:', error.message);
        return false;
    }
};

// Lấy proxy ngẫu nhiên
const getRandomProxy = (proxies) => {
    const index = Math.floor(Math.random() * proxies.length);
    return proxies[index];
};

// Lấy kích thước màn hình
const getScreenResolution = () => {
    const screenSize = robot.getScreenSize();
    return screenSize;
};

const processedProfiles = new Set(); // Danh sách các profile đã xử lý

const runWithConcurrency = async (profiles, maxThreads, pendingProfiles, proxies) => {
    const resolution = getScreenResolution();
    const windowWidth = 800;
    const windowHeight = 900;

    let positionX = 0;
    let positionY = 0;

    let masterBrowser = null;
    const slaveBrowsers = [];

    const startProfiles = async () => {
        for (let i = 0; i < profiles.length; i++) {
            if (processedProfiles.has(profiles[i].folderName)) {
                console.log(`Profile ${profiles[i].folderName} đã xử lý, bỏ qua.`);
                continue;
            }

            if (i === maxThreads) break;

            const isMaster = i === 0;
            const currentX = positionX;
            const currentY = positionY;

            const result = await handleProfile(profiles[i], currentX, currentY, isMaster, slaveBrowsers, proxies);

            if (result && isMaster) {
                masterBrowser = result.browser;

                // Lắng nghe sự kiện tắt trình duyệt chính
                masterBrowser.on('disconnected', async () => {
                    console.log('Trình duyệt chính đã đóng, đóng các trình duyệt phụ...');
                    for (const slave of slaveBrowsers) {
                        try {
                            if (slave.isConnected()) {
                                await slave.close();
                                console.log(`Trình duyệt phụ PID ${slave.process().pid} đã đóng.`);
                            }
                        } catch (error) {
                            console.error(`Lỗi khi đóng trình duyệt phụ: ${error.message}`);
                        }
                    }
                    slaveBrowsers.length = 0; // Xóa danh sách trình duyệt phụ

                    // Tiếp tục chạy các profile chưa xử lý
                    const remainingProfiles = pendingProfiles.filter(profile => !processedProfiles.has(profile.folderName));
                    console.log('Tiếp tục chạy các profile chưa xử lý...');
                    if (remainingProfiles.length > 0) {
                        await runWithConcurrency(remainingProfiles, maxThreads, pendingProfiles, proxies);
                    }
                });
            }

            if (result) {
                slaveBrowsers.push(result.browser);
                processedProfiles.add(profiles[i].folderName); // Đánh dấu profile đã xử lý
            }

            positionX += windowWidth;
            if (positionX + windowWidth > resolution.width * 2) {
                positionX = 0;
                positionY += windowHeight;
            }
        }
    };

    await startProfiles();
};

const handleProfile = async ({ folderName, proxy }, positionX, positionY, isMaster, slaves, proxies) => {
    let proxyParts = proxy.match(/^http:\/\/([^:]+):([^@]+)@([^:]+):(\d+)$/);
    if (!proxyParts) {
        console.error(`Proxy \"${proxy}\" không hợp lệ.`);
        return { browser: null, page: null, proxyHost: null };
    }

    let [_, proxyUsername, proxyPassword, proxyHost, proxyPort] = proxyParts;
    let proxyObj = { host: proxyHost, port: parseInt(proxyPort, 10), username: proxyUsername, password: proxyPassword };

    // Kiểm tra proxy
    console.log(`Đang kiểm tra proxy: ${proxyHost}:${proxyPort}`);
    let isProxyValid = await checkProxy(proxyObj);

    // Nếu proxy không hợp lệ, chọn proxy khác
    if (!isProxyValid) {
        console.error(`[${folderName}] Proxy không hợp lệ. Đang chọn proxy khác...`);
        let retries = 3;
        while (retries > 0) {
            proxyObj = getRandomProxy(proxies);
            console.log(`Thử proxy mới: ${proxyObj.host}:${proxyObj.port}`);
            if (await checkProxy(proxyObj)) {
                console.log(`Proxy hợp lệ: ${proxyObj.host}:${proxyObj.port}`);
                proxyUsername = proxyObj.username;
                proxyPassword = proxyObj.password;
                proxyHost = proxyObj.host;
                proxyPort = proxyObj.port;
                break;
            }
            retries--;
        }

        if (retries === 0) {
            console.error(`[${folderName}] Không tìm được proxy hợp lệ.`);
            return { browser: null, page: null, proxyHost: null };
        }
    }

    const userDataPath = path.join(__dirname, 'profiles', folderName);
    if (!fs.existsSync(userDataPath)) {
        fs.mkdirSync(userDataPath, { recursive: true });
    }

    async function launchBrowser(options) {
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                reject(new Error('Timed out while launching browser'));
            }, 30000);

            puppeteer.launch(options).then(browser => {
                clearTimeout(timeout);
                resolve(browser);
            }).catch(err => {
                clearTimeout(timeout);
                reject(err);
            });
        });
    }

    async function retry(fn, retries = 3) {
        let lastError;
        for (let i = 0; i < retries; i++) {
            try {
                return await fn();
            } catch (error) {
                lastError = error;
                console.error(`[${folderName}] [${proxyHost}] Retry ${i + 1} failed: ${error.message}`);
                if (i === retries - 1) {
                    throw lastError;
                }
            }
        }
    }

    try {
        const browser = await retry(() => launchBrowser({ 
            headless: false,
            args: [
                `--proxy-server=http://${proxyHost}:${proxyPort}`,
                `--user-data-dir=${userDataPath}`,
                '--disable-notifications',
                '--window-size=500,500',
                '--force-device-scale-factor=0.75',
                `--window-position=${positionX},${positionY}` // Thêm vị trí của cửa sổ
            ],
            defaultViewport: null
        }), 3);
        

        const page = await browser.newPage();

        const cookies = await page.cookies();
        for (let cookie of cookies) {
            if (cookie.name === 'proxy-auth-cookie' || cookie.domain === 'proxy.example.com') {
                await page.deleteCookie(cookie);
            }
        }
        console.log(`[${folderName}] [${proxyHost}] Đã xóa các cookie liên quan đến xác thực proxy.`);

        if (proxyUsername && proxyPassword) {
            await page.authenticate({
                username: proxyUsername,
                password: proxyPassword
            });
            console.log(`[${folderName}] [${proxyHost}] Đã xác thực proxy: ${proxyUsername}@${proxyHost}`);
        }

        await page.goto('https://web.telegram.org/a', { waitUntil: 'load', timeout: 60000 });

        await page.evaluate((folderName) => {
            const profileLabel = document.createElement('div');
            profileLabel.style.position = 'fixed';
            profileLabel.style.top = '100px';
            profileLabel.style.right = '10px';
            profileLabel.style.padding = '10px';
            profileLabel.style.backgroundColor = '#fff';
            profileLabel.style.color = '#000';
            profileLabel.style.border = '1px solid #ccc';
            profileLabel.style.fontSize = '16px';
            profileLabel.style.fontWeight = 'bold';
            profileLabel.textContent = `Profile: ${folderName}`;
            profileLabel.style.zIndex = '9999';
            document.body.appendChild(profileLabel);
        }, folderName);

        console.log(`[${folderName}] [${proxyHost}] Xử lý thành công!`);

        return { browser, page, proxyHost };

    } catch (error) {
        console.error(`[${folderName}] [${proxyHost}] Lỗi: ${error.message}`);
        return { browser: null, page: null, proxyHost };
    }
};


const run = async () => {
    const profiles = readProfilesFromFile();
    const threadCount = await readThreadCount(); // Đợi giá trị trả về từ readThreadCount
    const proxies = readProxiesFromFile();

    console.log(`Số luồng tối đa: ${threadCount}`);  // In giá trị đúng
    await runWithConcurrency(profiles, threadCount, profiles, proxies);
};

run();
