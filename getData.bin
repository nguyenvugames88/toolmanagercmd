const puppeteer = require('puppeteer');
const path = require('path');
const fs = require('fs');
const { HttpsProxyAgent } = require('https-proxy-agent');
const axios = require('axios');
const async = require('async');
const colors = require('colors');

let countProfile = 0
let hasRunRef = false; 
const MAX_PARALLEL_PROFILES = 10; // Giới hạn số profile chạy đồng thời

// Hàm sleep để tạm dừng
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
const failedProfiles = [];
const logoutError = [];
// Đọc danh sách profile và proxy từ file TXT
const readProfilesFromFile = () => {
    const filePath = path.join(__dirname, 'SelectedAllProfiles.txt');
    if (!fs.existsSync(filePath)) {
        console.error('File SelectedAllProfiles.txt không tồn tại.');
        process.exit(1);
    }
    const lines = fs.readFileSync(filePath, 'utf-8').split('\n').map(line => line.trim()).filter(Boolean);
    return lines.map(line => {
        const parts = line.split('|');
        return { folderName: parts[0], proxy: parts[1] };
    });
};

const checkProxy = async (proxy) => {
    try {
        // Kiểm tra định dạng proxy
        if (!proxy.username || !proxy.password || !proxy.host || !proxy.port) {
            console.error('Thông tin proxy không đầy đủ:', proxy);
            return false;
        }

        // Tạo HttpsProxyAgent
        const agent = new HttpsProxyAgent(`http://${proxy.username}:${proxy.password}@${proxy.host}:${proxy.port}`);

        // Gửi yêu cầu kiểm tra proxy
        const response = await axios.get('https://httpbin.org/ip', {
            httpsAgent: agent,
            timeout: 5000, // Timeout 5 giây
        });

        console.log('Proxy hoạt động:', response.data);
        return true;
    } catch (error) {
        console.error('Lỗi proxy:', error.message, error.code); // Log chi tiết lỗi
        return false;
    }
};

// Trích xuất thông tin từ URL iframe
const extractUserData = (url) => {
    let result = '';
    const queryStartIndex = url.indexOf('query_id%3D');
    if (queryStartIndex !== -1) {
        const queryEndIndex = url.indexOf('&', queryStartIndex);
        result = 'query_id=' + url.substring(queryStartIndex + 'query_id%3D'.length, queryEndIndex === -1 ? url.length : queryEndIndex);
    } else {
        const userStartIndex = url.indexOf('user%3D');
        if (userStartIndex !== -1) {
            const userEndIndex = url.indexOf('&', userStartIndex);
            result = 'user=' + url.substring(userStartIndex + 'user%3D'.length, userEndIndex === -1 ? url.length : userEndIndex);
        }
    }
    return result.replace(/%3D/g, '=').replace(/%25/g, '%').replace(/%26/g, '&') || '0';
};

async function reloadPage(page,folderName,proxyHost) {
    try {
        let retryCount = 0;
        const maxRetries = 10; // Số lần thử reload tối đa
        let isReloaded = false;
    
        while (!isReloaded && retryCount < maxRetries) {
            try {
                retryCount++;
                console.log(`[${folderName}] [${proxyHost}][Retry ${retryCount}] Đang reload trang...`.bgYellow);
                await page.reload({ waitUntil: 'networkidle0' }); // Đợi khi không còn kết nối mạng nào
    
                // Nếu reload thành công, đặt trạng thái isReloaded = true
                isReloaded = true;
                console.log(`[${folderName}] [${proxyHost}]Đã reload thành công và kiểm tra dialog.`.green);
            } catch (error) {
                console.error(`[Retry ${retryCount}] Lỗi khi reload: ${error.message}`);
    
                if (error.message.includes("Navigation timeout")) {
                    console.log(`[${folderName}] [${proxyHost}]Navigation timeout xảy ra, đang đợi và thử lại...`.yellow);
                    await new Promise(resolve => setTimeout(resolve, 5000)); // Đợi 5 giây trước khi thử lại
                } else {
                    throw error; // Nếu là lỗi khác, thoát vòng lặp và xử lý
                }
            }
        }
    
        if (!isReloaded) {
            console.error(`[${folderName}] [${proxyHost}]Không thể reload trang sau nhiều lần thử.`);
        }
    } catch (error) {
        console.error(`[${folderName}] [${proxyHost}]Lỗi khi reload hoặc kiểm tra dialog:`, error.message);
    }    
}
// Hàm load danh sách proxy từ file
async function loadProxyFromFile(filePath) {
    return new Promise((resolve, reject) => {
        fs.exists(filePath, (exists) => {
            if (!exists) {
                return reject(`File proxy không tồn tại: ${filePath}`);
            }

            fs.readFile(filePath, 'utf-8', (err, data) => {
                if (err) {
                    return reject(`Lỗi khi đọc file: ${err.message}`);
                }

                const proxies = data.split('\n')
                    .map(line => line.trim())
                    .filter(line => line && /^http:\/\/([^:]+):([^@]+)@([^:]+):(\d+)$/.test(line));

                console.log("Danh sách proxy load từ file:", proxies);
                resolve(proxies);
            });
        });
    });
}
// Hàm xử lý retry proxy
async function retryProxy(folderName, proxyHost, proxyObj, retryLimit = 3) {
    let isProxyValid = false;
    let retryCount = 0;

    while (!isProxyValid && retryCount < retryLimit) {
        console.log(`Đang kiểm tra proxy: ${JSON.stringify(proxyObj)}`);
        isProxyValid = await checkProxy(proxyObj);

        if (isProxyValid) {
            console.log(`[${folderName}] [${proxyHost}] Proxy hợp lệ.`);
            break;
        } else {
            console.error(`[${folderName}] [${proxyHost}] Proxy không hợp lệ. Thử lại sau 30 giây...`);
            await new Promise(resolve => setTimeout(resolve, 30000)); // Chờ 30 giây
            retryCount++;
        }
    }

    if (!isProxyValid) {
        console.error(`[${folderName}] [${proxyHost}] Proxy không hợp lệ sau ${retryLimit} lần thử. Dừng xử lý profile.`);

        const proxyFilePath = path.join(__dirname, 'proxy.txt');
        try {
            const proxies = await loadProxyFromFile(proxyFilePath);

            if (proxies.length === 0) {
                console.error(`[${folderName}] [${proxyHost}] Không có proxy nào trong file proxy.txt.`);
                return null;
            }

            const randomProxy = proxies[Math.floor(Math.random() * proxies.length)];
            console.log(`[${folderName}] [${proxyHost}] Chọn proxy ngẫu nhiên: ${randomProxy}`);

            const [_, username, password, host, port] = randomProxy.match(/^http:\/\/([^:]+):([^@]+)@([^:]+):(\d+)$/);
            proxyObj = { host, port: parseInt(port), username, password };

            return await retryProxy(folderName, proxyHost, proxyObj, retryLimit);
        } catch (error) {
            console.error(`[${folderName}] [${proxyHost}] Lỗi khi đọc proxy từ file:`, error);
            return null;
        }
    }

    console.log(`[${folderName}] [${proxyHost}] Đã sẵn sàng để tiếp tục.`);
    return proxyObj;
}



async function handleProfileWithProxy(folderName, proxy, url, head, retryLimit,retryCount) {
    const proxyParts = proxy.match(/^http:\/\/([^:]+):([^@]+)@([^:]+):(\d+)$/);
    if (!proxyParts) {
        console.error(`Proxy "${proxy}" không hợp lệ.`);
        return { browser: null, page: null, proxyHost: null }; // Return proxyHost as well// Trả về null nếu proxy không hợp lệ
    }

    let  [_, proxyUsername, proxyPassword, proxyHost, proxyPort] = proxyParts;
    let proxyObj = { host: proxyHost, port: parseInt(proxyPort, 10), username: proxyUsername, password: proxyPassword };

    // Kiểm tra tính hợp lệ của proxy và thay đổi nếu cần
    const updatedProxy = await retryProxy(folderName, proxyHost, proxyObj, retryLimit);

    if (updatedProxy) {
        // Nếu proxy được cập nhật thành công, sử dụng proxy mới
        proxyObj = updatedProxy;
        proxyHost = updatedProxy.host; // Cập nhật lại proxyHost nếu cần
        proxyPort = updatedProxy.port;
        proxyUsername = updatedProxy.username;
        proxyPassword= updatedProxy.password
    } else {
        // Nếu không có proxy hợp lệ, return với giá trị null
        return { browser: null, page: null, proxyHost: null };
    }

    const userDataPath = path.join(__dirname, 'profiles', folderName);
    if (!fs.existsSync(userDataPath)) {
        fs.mkdirSync(userDataPath, { recursive: true });
    }

    // Hàm khởi chạy trình duyệt với proxy
    async function launchBrowser(options) {
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                reject(new Error('Timed out while launching browser'));
            }, 30000); // Thời gian chờ tối đa 30 giây

            puppeteer.launch(options).then(browser => {
                clearTimeout(timeout);
                resolve(browser);
            }).catch(err => {
                clearTimeout(timeout);
                reject(err);
            });
        });
    }

    // Hàm retry để thử lại khi có lỗi
    async function retry(fn, retries = 3) {
        let lastError;
        for (let i = 0; i < retries; i++) {
            try {
                return await fn();
            } catch (error) {
                lastError = error;
                console.error(`[${folderName}] [${proxyHost}] Retry ${i + 1} failed: ${error.message}`);
                if (i === retries - 1) {
                    throw lastError;
                }
            }
        }
    }

    try {
        const browser = await retry(() => launchBrowser({
            headless: head,
            args: [
                `--proxy-server=http://${proxyHost}:${proxyPort}`,
                `--user-data-dir=${userDataPath}`,
                '--disable-notifications',
                '--disable-extensions',
                '--no-sandbox',
                '--disable-gpu',
                '--window-size=800,800',
                '--force-device-scale-factor=0.5'
            ],
            defaultViewport: { width: 800, height: 1000 }
        }), 3);

        const page = await browser.newPage();

        // Xử lý các cookies và xác thực proxy
        const cookies = await page.cookies();
        for (let cookie of cookies) {
            if (cookie.name === 'proxy-auth-cookie' || cookie.domain === 'proxy.example.com') {
                await page.deleteCookie(cookie);
            }
        }
        console.log(`[${folderName}] [${proxyHost}] Đã xóa các cookie liên quan đến xác thực proxy.`.blue);

        // Xác thực proxy nếu có
        if (proxyUsername && proxyPassword) {
            await page.authenticate({
                username: proxyUsername,
                password: proxyPassword
            });
            console.log(`[${folderName}] [${proxyHost}] Đã xác thực proxy: ${proxyUsername}@${proxyHost}`.green);
        }

        // Truy cập URL
        await page.goto(url, { waitUntil: 'load', timeout: 60000 });

        // Thêm thông báo tên profile
        await page.evaluate((folderName) => {
            const profileLabel = document.createElement('div');
            profileLabel.style.position = 'fixed';
            profileLabel.style.top = '100px';
            profileLabel.style.right = '10px';
            profileLabel.style.padding = '10px';
            profileLabel.style.backgroundColor = '#fff';
            profileLabel.style.color = '#000';
            profileLabel.style.border = '1px solid #ccc';
            profileLabel.style.fontSize = '16px';
            profileLabel.style.fontWeight = 'bold';
            profileLabel.textContent = `Profile: ${folderName}`;
            profileLabel.style.zIndex = '9999';
            document.body.appendChild(profileLabel);
        }, folderName);

        console.log(`[${folderName}] [${proxyHost}] Xử lý thành công!`.green);

        // Trả về browser và page sau khi xử lý xong
        return { browser, page, proxyHost };

    } catch (error) {
        if (error.message.includes('Failed to launch the browser process')) {
            console.error(`[${folderName}] [${proxyHost}] Không thể khởi chạy trình duyệt:`, error.message);
            logoutError.push(`Profile: ${folderName} - Lỗi profile cần tạo lại.`);        
            return { browser: null, page: null, proxyHost: proxyHost };
        } else if (error.message.includes('net::ERR_INVALID_AUTH_CREDENTIALS')) {
            // Khi gặp lỗi "net::ERR_INVALID_AUTH_CREDENTIALS"
            console.error(`[${folderName}] [${proxyHost}] Lỗi xác thực proxy: ${error.message}`);

            // Lưu lại thông tin vào danh sách lỗi để chạy lại sau (nếu cần thiết)
            failedProfiles.push({ folderName, proxy });

            // Tắt mở lại trình duyệt và xóa xác thực proxy
            try {
                // Đóng trình duyệt hiện tại
                await browser.close();
                console.log(`[${folderName}] [${proxyHost}] Đã đóng trình duyệt vì lỗi xác thực proxy.`.blue);
            } catch (closeError) {
                console.error(`[${folderName}] [${proxyHost}] Lỗi khi đóng trình duyệt: ${closeError.message}`);
            }

            // Tiến hành lại với việc mở trình duyệt mới và xác thực proxy lại
            try {
                const newBrowser = await retry(() => launchBrowser({
                    headless: head,
                    args: [
                        `--proxy-server=http://${proxyHost}:${proxyPort}`,  // Cấu hình proxy
                        `--user-data-dir=${userDataPath}`, // Thư mục dữ liệu người dùng
                        '--disable-notifications',
                        '--disable-extensions',
                        '--no-sandbox',
                        '--disable-gpu',
                        '--window-size=800,800',
                        '--force-device-scale-factor=0.5'
                    ],
                    defaultViewport: { width: 800, height: 700 }
                }), 3);

                console.log(`[${folderName}] [${proxyHost}] Đã mở lại trình duyệt sau khi gặp lỗi xác thực proxy.`.blue);

                // Mở lại trang mới hoặc tiếp tục với quy trình của bạn
                const page = await newBrowser.newPage();
                // Lấy danh sách tất cả cookies
                const cookies = await page.cookies();

                // Xóa tất cả cookies liên quan đến xác thực proxy (giả sử cookie xác thực có tên là 'proxy-auth-cookie')
                for (let cookie of cookies) {
                    // Kiểm tra và xóa các cookie liên quan đến xác thực proxy
                    if (cookie.name === 'proxy-auth-cookie' || cookie.domain === 'proxy.example.com') { // Thay đổi theo tên hoặc domain cookies proxy của bạn
                        await page.deleteCookie(cookie);
                        console.log(`[${folderName}] [${proxyHost}] Đã xóa cookie: ${cookie.name} với domain: ${cookie.domain}`.blue);
                    }
                }
                // Xác thực lại proxy (nếu cần thiết)
                if (proxyUsername && proxyPassword) {
                    await page.authenticate({
                        username: proxyUsername,
                        password: proxyPassword
                    });
                    console.log(`[${folderName}] [${proxyHost}] Đã xác thực lại proxy: ${proxyUsername}@${proxyHost}`);
                }
                // Tiến hành điều hướng và xử lý các bước tiếp theo
                await page.goto(url, { waitUntil: 'load', timeout: 60000 });

                // Trả về browser và page nếu thành công
                return { browser, page, proxyHost };

            } catch (retryError) {
                console.error(`[${folderName}] [${proxyHost}] Lỗi khi mở lại trình duyệt:`, retryError.message);
                // Lưu vào danh sách lỗi để thực hiện lại sau nếu cần
                failedProfiles.push({ folderName, proxy });
            }
        } else {
            // Xử lý các lỗi khác
            console.error(`[${folderName}] [${proxyHost}] Lỗi không xác định:`, error.message);
            failedProfiles.push({ folderName, proxy });
        }

        // Trả về null nếu có lỗi
        return { browser: null, page: null, proxyHost: proxyHost };
    }
}

async function checkLogout(page, folderName, proxyHost, logoutError, browser) {
    try {
        // Kiểm tra xem có phần tử tiêu đề 'h1' hay không
        const loginElement = await page.$('h1');
        if (loginElement) {
            const textContent = await page.evaluate(element => element.textContent, loginElement);
            // Kiểm tra nội dung nếu chứa 'Log in to Telegram by QR Code'
            if (textContent.includes('Log in to Telegram by QR Code')) {
                console.log(`[${folderName}] [${proxyHost}] Đã đăng xuất khỏi Telegram. Chuyển qua profile khác.`.bgRed);
                logoutError.push(`Profile: ${folderName} - Đã đăng xuất khỏi Telegram`);
                await browser.close(); // Đóng trình duyệt
                return true; // Trả về true để báo rằng đã đăng xuất
            }
        }
        return false; // Không có dấu hiệu đăng xuất
    } catch (error) {
        console.error(`[${folderName}] [${proxyHost}] Lỗi khi kiểm tra đăng xuất:`, error);
        return true; // Trả về true trong trường hợp có lỗi để đảm bảo không tiếp tục xử lý profile
    }
}
    
async function runRef(page, linkRef) {
    try {
        // Bước 1: Kiểm tra và nhấp vào nút Open menu
        const menuButton = await page.$('button[aria-label="Open menu"]');
        if (menuButton) {
            console.log("Đã tìm thấy nút 'Open menu', tiến hành nhấp...");
            await menuButton.click();
            await page.waitForTimeout(500);
        } else {
            console.log("Không tìm thấy nút 'Open menu'.");
            return false;
        }

        // Bước 2: Nhấp vào biểu tượng Saved Messages
        const savedMessagesIcon = await page.$('i.icon.icon-saved-messages');
        if (savedMessagesIcon) {
            console.log("Đã tìm thấy biểu tượng 'Saved Messages', tiến hành nhấp...");
            await savedMessagesIcon.click();
            await page.waitForTimeout(500);
        } else {
            console.log("Không tìm thấy biểu tượng 'Saved Messages'.");
            return false;
        }

        // Bước 3: Kiểm tra tất cả phần tử <a> có thuộc tính href
        const allLinks = await page.$$('a[href]'); // Lấy tất cả phần tử <a> có thuộc tính href
        for (const link of allLinks) {
            const href = await page.evaluate(el => el.getAttribute('href'), link); // Lấy giá trị href
            if (href === linkRef) {
                console.log(`Đã tìm thấy liên kết có href khớp với linkRef: ${href}`);
                await link.click(); // Nhấp vào liên kết nếu khớp
                console.log("Đã nhấp vào liên kết thành công.");
                return true;
            }
        }

        // Bước 4: Nếu không tìm thấy liên kết, nhập linkRef vào ô chỉnh sửa
        const messageInput = await page.$('div[id="editable-message-text"]');
        if (messageInput) {
            console.log("Không tìm thấy liên kết. Tiến hành nhập linkRef vào ô văn bản...");
            await messageInput.type(linkRef, { delay: 50 });
            await page.keyboard.press('Enter');
            console.log("Đã nhập linkRef và nhấn Enter.");
        } else {
            console.log("Không tìm thấy ô nhập văn bản.");
            return false;
        }

        // Bước 5: Kiểm tra lại sau khi nhập liệu
        await page.waitForTimeout(1000);
        const updatedLinks = await page.$$('a[href]');
        for (const link of updatedLinks) {
            const href = await page.evaluate(el => el.getAttribute('href'), link);
            if (href === linkRef) {
                console.log(`Đã tìm thấy liên kết sau khi nhập linkRef: ${href}`);
                await link.click();
                console.log("Đã nhấp vào liên kết thành công.");
                return true;
            }
        }

        console.log("Vẫn không tìm thấy liên kết sau khi nhập linkRef.");
        return false;
    } catch (error) {
        console.error("Lỗi trong quá trình thực hiện runRef:", error);
        return false;
    }
}
async function processIframeDetection(browser, page, folderName, proxyHost, elementSelector,linkRef, dataFilePath, logoutError,proxy,url,head,retryLimit) {
    let confirmClicked = false;
    let iframeDetected = false;
    let retryAttempts = 0;
    let reloadAttempts = 0;
    let loopAttempts = 0;
    const maxRetries = 5;
    const maxReloads = 5;
    const maxLoopAttempts = 20;

    while (!iframeDetected) {
        try {
            loopAttempts++; // Tăng biến đếm số vòng lặp

            // Kiểm tra số lần lặp đã vượt quá giới hạn chưa
            if (loopAttempts > maxLoopAttempts) {
                console.log(`[${folderName}] [${proxyHost}] Đã đạt số vòng lặp tối đa (${maxLoopAttempts}). Thoát để tránh chạy vô hạn.`);
                logoutError.push(`Profile: ${folderName} - Đã đạt số vòng lặp tối đa (${maxLoopAttempts}). Thoát để tránh chạy vô hạn.`);
                if (browser && browser.isConnected()) {
                    await browser.close();
                }
                break; // Thoát vòng lặp
            }

            try {
                console.log(`[${folderName}] [${proxyHost}] Đang chờ phần tử button[class="Button tiny primary fluid has-ripple"]...`);
                await page.waitForSelector('button[class="Button tiny primary fluid has-ripple"]', { visible: true, timeout: 5000 });
                await new Promise(resolve => setTimeout(resolve, 2000)); // Thêm thời gian chờ trước khi click
                console.log(`[${folderName}] [${proxyHost}] Tìm thấy phần tử button[class="Button tiny primary fluid has-ripple"]! Đang click...`.blue);
                await page.click('button[class="Button tiny primary fluid has-ripple"]');
            } catch (error) {
                // Gọi hàm kiểm tra đăng xuất
                const isLoggedOut = await checkLogout(page, folderName, proxyHost, logoutError, browser);
                if (isLoggedOut) {
                    break; // Thoát vòng lặp nếu đã đăng xuất
                }

                if (error.name === 'TimeoutError') {
                    console.log(`[${folderName}] [${proxyHost}] Không tìm thấy phần tử button[class="Button tiny primary fluid has-ripple"]. Tiếp tục.`.yellow); 
                } else {
                    console.error(`[${folderName}] [${proxyHost}] Lỗi khi xử lý phần tử:`, error.message);
                }
            }

            try {
                console.log(`[${folderName}] [${proxyHost}] Đang chờ phần tử "${elementSelector}"...`);
                await page.waitForSelector(elementSelector, { visible: true });
                await new Promise(resolve => setTimeout(resolve, 2000));
                console.log(`[${folderName}] [${proxyHost}] Tìm thấy phần tử "${elementSelector}". Đang click...`.blue);
        
                await page.click(elementSelector); // Thử click vào phần tử
            } catch (error) {
                console.error(`[${folderName}] [${proxyHost}] Không tìm thấy phần tử "${elementSelector}".`, error.message);
                // Gọi hàm kiểm tra đăng xuất
                const isLoggedOut = await checkLogout(page, folderName, proxyHost, logoutError, browser);
                if (isLoggedOut) {
                    break; // Thoát vòng lặp nếu đã đăng xuất
                }
        
                try {
                    // Gõ "/start" vào div có id="editable-message-text"
                    console.log(`[${folderName}] [${proxyHost}] Đang nhập "/start" vào div[id="editable-message-text"]...`);
                    try {
                        await page.type('div[id="editable-message-text"]', '/start');
                        await page.keyboard.press('Enter');
                    } catch (typeError) {
                        console.error(`[${folderName}] [${proxyHost}] Lỗi khi nhập "/start" hoặc nhấn Enter:`, typeError.message);
                    }
        
                    // Chờ một chút trước khi tìm lại
                    console.log(`[${folderName}] [${proxyHost}] Đợi một lát trước khi tìm lại phần tử "${elementSelector}"...`);
                    await new Promise(resolve => setTimeout(resolve, 2000));
        
                    // Tìm lại phần tử
                    console.log(`[${folderName}] [${proxyHost}] Đang tìm lại phần tử "${elementSelector}"...`);
                    await page.waitForSelector(elementSelector, { visible: true });
                    console.log(`[${folderName}] [${proxyHost}] Tìm thấy phần tử "${elementSelector}". Đang click...`.blue);
        
                    await page.click(elementSelector); // Thử click lại
                } catch (retryError) {
                    console.error(`[${folderName}] [${proxyHost}] Lỗi khi retry với phần tử "${elementSelector}":`, retryError.message);
                    // Gọi hàm kiểm tra đăng xuất
                    const isLoggedOut = await checkLogout(page, folderName, proxyHost, logoutError, browser);
                    if (isLoggedOut) {
                        break; // Thoát vòng lặp nếu đã đăng xuất
                    }
                    // Reload trang nếu vẫn thất bại
                    try {
                        console.log(`[${folderName}] [${proxyHost}] Đang reload trang...`);
                        await page.reload({ waitUntil: 'networkidle0' }); // Đợi đến khi mạng ổn định
        
                        console.log(`[${folderName}] [${proxyHost}] Đã reload trang. Đang tìm lại phần tử "${elementSelector}"...`);
                        await page.waitForSelector(elementSelector, { visible: true, timeout: 5000 }); // Chờ thêm một chút để tìm phần tử
        
                        console.log(`[${folderName}] [${proxyHost}] Tìm thấy phần tử "${elementSelector}". Đang click...`.blue);
                        await page.click(elementSelector); // Thử click sau reload
                    } catch (reloadError) {
                        console.error(`[${folderName}] [${proxyHost}] Không tìm thấy phần tử "${elementSelector}" sau khi reload:`, reloadError.message);
                        
                        // Gọi hàm kiểm tra đăng xuất
                        const isLoggedOut = await checkLogout(page, folderName, proxyHost, logoutError, browser);
                        if (isLoggedOut) {
                            break; // Thoát vòng lặp nếu đã đăng xuất
                        }

                        // Kiểm tra nếu tồn tại phần tử với aria-label="Text not allowed"
                        const textNotAllowedSelector = 'div[aria-label="Text not allowed"]';
                        const isTextNotAllowed = await page.$(textNotAllowedSelector);
        
                        // Biến toàn cục hoặc đặt trong phạm vi cần thiết để kiểm soát việc chạy runRef

                        if (isTextNotAllowed) {
                            console.error(`[${folderName}] [${proxyHost}] Chưa chạy Ref cho tài khoản Telegram.`);
                            if (linkRef){
                            // Chỉ chạy runRef nếu chưa từng chạy
                                if (!hasRunRef) {
                                    await runRef(page, linkRef);
                                    hasRunRef = true; // Đánh dấu đã chạy
                                }

                                // Đóng trình duyệt nếu còn kết nối
                                if (browser && browser.isConnected()) {
                                    await browser.close();
                                }

                                // Thực hiện lại hàm handleProfileWithProxy nếu cần
                                await handleProfileWithProxy(folderName, proxy, url, head, retryLimit, retryCount);
                            }
                            // Lưu lỗi vào danh sách logoutError
                            logoutError.push(`Profile: ${folderName} - Chưa Ref cho Telegram này`);

                            // Đóng trình duyệt lần cuối nếu còn kết nối
                            if (browser && browser.isConnected()) {
                                await browser.close();
                            }

                            break; // Thoát vòng lặp
                        } else {
                            // Gọi hàm kiểm tra đăng xuất
                            const isLoggedOut = await checkLogout(page, folderName, proxyHost, logoutError, browser);
                            if (isLoggedOut) {
                                break; // Thoát vòng lặp nếu đã đăng xuất
                            }
                            console.error(`[${folderName}] [${proxyHost}] Phần tử "${elementSelector}" vẫn không tìm thấy sau khi reload.`);
                            logoutError.push(`Profile: ${folderName} - Phần tử "${elementSelector}" vẫn không tìm thấy`); // Lưu lỗi
                            if (browser && browser.isConnected()) {
                                await browser.close();
                            }
                            break; // Thoát vòng lặp
                        }
                    }
                }
            }
            // Chờ nút "Confirm"
            console.log(`[${folderName}] [${proxyHost}] Đang chờ nút "Confirm"...`);
            await page.waitForSelector('button.Button.confirm-dialog-button.default.primary.text', { timeout: 5000 });
            await new Promise(resolve => setTimeout(resolve, 2000)); 
            console.log(`[${folderName}] [${proxyHost}] Tìm thấy nút "Confirm". Đang click...`.blue);
            await page.click('button.Button.confirm-dialog-button.default.primary.text');

            // Kiểm tra iframe
            console.log(`[${folderName}] [${proxyHost}] Chờ để kiểm tra iframe...`);
            await page.waitForSelector('iframe', { timeout: 10000 }); // Chờ tối đa 10 giây
            const iframe = await page.$('iframe');
            
            if (iframe) {
                console.log(`[${folderName}] [${proxyHost}] Iframe đã xuất hiện!`.green);
                const iframeSrc = await page.evaluate(iframe => iframe.src, iframe);
                if (!iframeSrc || iframeSrc.trim() === '') {
                    console.log(`[${folderName}] [${proxyHost}] Src của iframe trống hoặc không hợp lệ. Reload lại trang.`.yellow);
                    await reloadPage(page,folderName, proxyHost);
                    retryAttempts = 0;
                    reloadAttempts++;
                    if (reloadAttempts >= maxReloads) {
                        console.log(`[${folderName}] [${proxyHost}] Đã reload ${maxReloads} lần mà không thấy iframe. Thoát.`.bgRed);
                        logoutError.push(`Profile: ${folderName} - Không tìm thấy Iframe.`);
                        await browser.close();
                        break;
                    }
                } else {
                    iframeDetected = true;
                    const query_id = extractUserData(iframeSrc);
                    console.log(`[${folderName}] [${proxyHost}] query_id của iframe: ${query_id}`.green);
                    fs.appendFileSync(dataFilePath, `${query_id}\n`, 'utf-8');
                    console.log(`[${folderName}] [${proxyHost}] Đã ghi query_id vào file: ${dataFilePath}`.green);
                    await browser.close();
                    console.log(`[${folderName}] [${proxyHost}] Đã đóng trình duyệt cho profile: ${folderName}`.green);
                    countProfile++;
                }
            } else {
                console.log(`[${folderName}] [${proxyHost}] Iframe chưa xuất hiện. Quay lại click nút "Play".`);
                // Gọi hàm kiểm tra đăng xuất
                const isLoggedOut = await checkLogout(page, folderName, proxyHost, logoutError, browser);
                if (isLoggedOut) {
                    break; // Thoát vòng lặp nếu đã đăng xuất
                }
                retryAttempts++;
                if (retryAttempts >= maxRetries) {
                    console.log(`[${folderName}] [${proxyHost}] Đã thử ${maxRetries} lần mà không thấy iframe. Reload lại trang.`.yellow);
                    await reloadPage(page,folderName, proxyHost);
                    retryAttempts = 0;
                    reloadAttempts++;
                    if (reloadAttempts >= maxReloads) {
                        console.log(`[${folderName}] [${proxyHost}] Đã reload ${maxReloads} lần mà không thấy iframe. Thoát.`.bgRed);
                        logoutError.push(`Profile: ${folderName} - Không tìm thấy Iframe.`);
                        await browser.close();
                        break;
                    }
                }
            }
        } catch (err) {
            if (err.name === 'TimeoutError') {
                console.log(`[${folderName}] [${proxyHost}] Nút "Confirm" không xuất hiện. Kiểm tra iframe...`);
                try {
                    const loginElement = await page.$('h1');
                    if (loginElement) {
                        const textContent = await page.evaluate(element => element.textContent, loginElement);
                        if (textContent.includes('Log in to Telegram by QR Code')) {
                            console.log(`[${folderName}] [${proxyHost}] Đã đăng xuất khỏi Telegram. Chuyển qua profile khác.`.bgRed);
                            logoutError.push(`Profile: ${folderName} - Đã đăng xuất khỏi Telegram`);
                            await browser.close();
                            break;
                        }
                    }
                    await page.waitForSelector('iframe', { timeout: 10000 });
                    const iframe = await page.$('iframe');
                    if (iframe) {
                        const iframeSrc = await page.evaluate(iframe => iframe.src, iframe);
                        if (!iframeSrc || iframeSrc.trim() === '') {
                            console.log(`[${folderName}] [${proxyHost}] Src của iframe trống hoặc không hợp lệ. Reload lại trang.`);
                            await reloadPage(page,folderName, proxyHost);
                            retryAttempts = 0;
                            reloadAttempts++;
                            if (reloadAttempts >= maxReloads) {
                                console.log(`[${folderName}] [${proxyHost}] Đã reload ${maxReloads} lần mà không thấy iframe. Thoát.`.bgRed);
                                logoutError.push(`Profile: ${folderName} - Không tìm thấy Iframe.`);
                                await browser.close();
                                break;
                            }
                        } else {
                            iframeDetected = true;
                            const query_id = extractUserData(iframeSrc);
                            console.log(`[${folderName}] [${proxyHost}] query_id của iframe: ${query_id}`.green);
                            fs.appendFileSync(dataFilePath, `${query_id}\n`, 'utf-8');
                            console.log(`[${folderName}] [${proxyHost}] Đã ghi query_id vào file: ${dataFilePath}`.green);
                            await browser.close();
                            console.log(`[${folderName}] [${proxyHost}] Đã đóng trình duyệt cho profile: ${folderName}`.green);
                            countProfile++;
                        }
                    }
                } catch (error) {
                    await reloadPage(page,folderName, proxyHost);
                }
            } else {
                // Gọi hàm kiểm tra đăng xuất
                const isLoggedOut = await checkLogout(page, folderName, proxyHost, logoutError, browser);
                if (isLoggedOut) {
                    break; // Thoát vòng lặp nếu đã đăng xuất
                }                           
                console.error(`[${folderName}] [${proxyHost}] Lỗi khác xảy ra:`, err);
                logoutError.push(`Profile: ${folderName} - Lỗi: ${err.message}`);
                if (browser && browser.isConnected()) {
                    await browser.close();
                }
                break;
            }
        }
    }
}

const processProfile = async ({ folderName, proxy }, { url, elementSelector,linkRef, dataFilePath, showBrowser }) => {
    console.log(`[${folderName}] Bắt đầu xử lý profile với proxy: ${proxy}`.bgMagenta);
    const retryLimit = 3;
    const head = Number(showBrowser) === 1 ? false : true;

    let browser, page, proxyHost; // Declare browser, page, and proxyHost variables

    try {
        // Destructure to get proxyHost from handleProfileWithProxy return
        const result = await handleProfileWithProxy(folderName, proxy, url, head, retryLimit);
        browser = result.browser;
        page = result.page;
        proxyHost = result.proxyHost;

        //console.log(browser, page, proxyHost);

        if (!browser || !page || !proxyHost) {
            console.error(`[${folderName}] Không thể kết nối với proxy.`);
            logoutError.push(`Profile: ${folderName} - Không thể kết nối với proxy.`);
            // Close browser if it's opened before returning
            if (browser && browser.isConnected()) {
                try {
                    await browser.close();
                    console.log(`[${folderName}] Đã đóng trình duyệt do lỗi kết nối proxy.`.bgRed);
                } catch (closeError) {
                    console.error(`[${folderName}] Lỗi khi đóng trình duyệt: ${closeError.message}`);
                }
            }
            return; // Early return if no proxy connection
        }
        console.log(`[${folderName}] Đã kết nối với proxy thành công.`.green);

        // Proceed with iframe detection
        await processIframeDetection(browser, page, folderName, proxyHost, elementSelector,linkRef, dataFilePath, logoutError,proxy, url, head, retryLimit);      
        
        console.log(`[${folderName}] Đã hoàn thành quá trình xử lý iframe thứ (${countProfile}).`.bgGreen);
    } catch (error) {
        console.error(`[${folderName}] Xảy ra lỗi khi xử lý profile:`, error);
        logoutError.push(`Profile: ${folderName} - Lỗi: ${error.message}`);

        // Ensure browser is closed in case of error
        if (browser && browser.isConnected()) {
            try {
                await browser.close();
                console.log(`[${folderName}] Đã đóng trình duyệt do lỗi.`.bgRed);
            } catch (closeError) {
                console.error(`[${folderName}] Lỗi khi đóng trình duyệt: ${closeError.message}`);
            }
        }
    }
};



async function retryFailedProfiles(failedProfiles, url, elementSelector,linkRef, dataFilePath, theard, showBrowser) {
    if (failedProfiles.length > 0) {
        console.log(`Thử lại ${failedProfiles.length} profile gặp lỗi...`.bgMagenta);

        try {
            // Sử dụng async.eachLimit để giới hạn số lượng tác vụ chạy đồng thời
            await new Promise((resolve, reject) => {
                async.eachLimit(failedProfiles, theard, async (profile) => {
                    try {
                        // Xử lý lại mỗi profile bị lỗi
                        await processProfile(profile, { url, elementSelector,linkRef, dataFilePath, showBrowser });
                        console.log(`[${profile.folderName}] [${profile.proxy}] Đã xử lý lại thành công`.blue);
                    } catch (err) {
                        console.error(`[${profile.folderName}] [${profile.proxy}] Xử lý lại gặp lỗi: ${err.message}`);
                    }
                }, (err) => {
                    if (err) {
                        console.error('Lỗi khi chạy lại các profile:', err.message);
                        reject(err); // Nếu có lỗi trong khi xử lý, reject promise
                    } else {
                        resolve(); // Nếu không có lỗi, resolve promise
                    }
                });
            });
        } catch (error) {
            console.error('Lỗi trong retryFailedProfiles:', error.message);
        }
    } else {
        console.log('Không có profile nào để thử lại.');
    }
}


const run = async () => {
    try{
        const gameData = fs.readFileSync('ini/select_game.txt', 'utf-8').split('\n').map(line => line.trim()).filter(Boolean);

        if (gameData.length === 0) {
            console.error('Không có dữ liệu trong file select_game.txt');
            return;
        }

        const [nameTask, url, elementSelector,linkRef, dataFilePath,theard,showBrowser] = gameData[0].split('|');
        //console.log('showBrowser: ',showBrowser)
        fs.writeFileSync(dataFilePath, '', 'utf-8'); // Xóa dữ liệu cũ
        const profiles = readProfilesFromFile();

        //MAX_PARALLEL_PROFILES = theard
        
        // Sử dụng async.eachLimit để giới hạn số lượng tác vụ chạy đồng thời
        await new Promise((resolve, reject) => {
            async.eachLimit(profiles, theard, async (profile) => {
                await processProfile(profile, { url, elementSelector,linkRef, dataFilePath,showBrowser });
            }, (err) => {
                if (err) {
                    reject(err);
                } else {
                    resolve();
                }
            });
        });

        await retryFailedProfiles(failedProfiles,url, elementSelector,linkRef, dataFilePath,theard,showBrowser); 

        if (logoutError.length > 0) {
            const bom = '\uFEFF'; // BOM cho UTF-8
            const dataWithTaskName = logoutError.map(line => `${nameTask}: ${line}`).join('\n'); // Thêm nameTask vào đầu mỗi dòng

            // Kiểm tra nếu tệp chưa tồn tại, thêm BOM
            fs.access('ini/LogOut.txt', fs.constants.F_OK, (err) => {
                const initialContent = err ? bom : ''; // Nếu tệp chưa tồn tại, thêm BOM
                const contentToAppend = initialContent + dataWithTaskName + '\n';

                // Ghi thêm dữ liệu vào file
                fs.appendFile('ini/LogOut.txt', contentToAppend, (err) => {
                    if (err) {
                        console.error('Lỗi khi ghi lỗi vào file:', err);
                    } else {
                        console.log('Đã ghi thêm lỗi vào file: ini/LogOut.txt');
                    }
                });
            });
        } else {
            console.log('Không có lỗi nào cần ghi ra file.');
        }
        console.log(`Hoàn thành ${countProfile} profile.`);
        await new Promise(resolve => setTimeout(resolve, 5000)); 
        process.exit(0); // Thoát chương trình
    }catch(error) {
        console.error(` Lỗi với": `, error.message);
        await new Promise(resolve => setTimeout(resolve, 5000)); 
        process.exit(0); // Thoát chương trình
    }
};

run();
