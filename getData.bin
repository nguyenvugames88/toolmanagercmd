const puppeteer = require('puppeteer');
const path = require('path');
const fs = require('fs');
const { HttpsProxyAgent } = require('https-proxy-agent');
const axios = require('axios');
const async = require('async');
const colors = require('colors');

let countProfile = 0
const MAX_PARALLEL_PROFILES = 10; // Giới hạn số profile chạy đồng thời

// Hàm sleep để tạm dừng
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
const failedProfiles = [];
const logoutError = [];
// Đọc danh sách profile và proxy từ file TXT
const readProfilesFromFile = () => {
    const filePath = path.join(__dirname, 'SelectedAllProfiles.txt');
    if (!fs.existsSync(filePath)) {
        console.error('File SelectedAllProfiles.txt không tồn tại.');
        process.exit(1);
    }
    const lines = fs.readFileSync(filePath, 'utf-8').split('\n').map(line => line.trim()).filter(Boolean);
    return lines.map(line => {
        const parts = line.split('|');
        return { folderName: parts[0], proxy: parts[1] };
    });
};

// Kiểm tra proxy
const checkProxy = async (proxy) => {
    try {
        const agent = new HttpsProxyAgent(`http://${proxy.username}:${proxy.password}@${proxy.host}:${proxy.port}`);
        const response = await axios.get('https://httpbin.org/ip', { httpsAgent: agent });
        console.log('Proxy hoạt động:', response.data);
        return true;
    } catch (error) {
        console.error('Lỗi proxy:', error.message);
        return false;
    }
};

// Trích xuất thông tin từ URL iframe
const extractUserData = (url) => {
    let result = '';
    const queryStartIndex = url.indexOf('query_id%3D');
    if (queryStartIndex !== -1) {
        const queryEndIndex = url.indexOf('&', queryStartIndex);
        result = 'query_id=' + url.substring(queryStartIndex + 'query_id%3D'.length, queryEndIndex === -1 ? url.length : queryEndIndex);
    } else {
        const userStartIndex = url.indexOf('user%3D');
        if (userStartIndex !== -1) {
            const userEndIndex = url.indexOf('&', userStartIndex);
            result = 'user=' + url.substring(userStartIndex + 'user%3D'.length, userEndIndex === -1 ? url.length : userEndIndex);
        }
    }
    return result.replace(/%3D/g, '=').replace(/%25/g, '%').replace(/%26/g, '&') || '0';
};

async function checkAndDismissDialog(page) {
    try {
        const dialogs = await page.$$('dialog');  // Kiểm tra tất cả các hộp thoại (dialog) đang mở

        if (dialogs.length > 0) {
            console.log("Dialog found! Đang tắt dialog...");
            for (let dialog of dialogs) {
                // Đóng tất cả các dialog nếu có
                await dialog.evaluate(dialog => dialog.close());
            }
        } else {
            console.log("Không có dialog nào mở.");
        }
    } catch (error) {
        console.error("Lỗi khi kiểm tra hoặc đóng dialog:", error.message);
    }
}

async function reloadPage(folderName,proxyHost) {
    try {
        let retryCount = 0;
        const maxRetries = 5; // Số lần thử reload tối đa
        let isReloaded = false;
    
        while (!isReloaded && retryCount < maxRetries) {
            try {
                retryCount++;
                console.log(`[${folderName}] [${proxyHost}][Retry ${retryCount}] Đang reload trang...`);
                await page.reload({ waitUntil: 'networkidle0' }); // Đợi khi không còn kết nối mạng nào
    
                // Nếu reload thành công, đặt trạng thái isReloaded = true
                isReloaded = true;
                console.log(`[${folderName}] [${proxyHost}]Đã reload thành công và kiểm tra dialog.`);
            } catch (error) {
                console.error(`[Retry ${retryCount}] Lỗi khi reload: ${error.message}`);
    
                if (error.message.includes("Navigation timeout")) {
                    console.log(`[${folderName}] [${proxyHost}]Navigation timeout xảy ra, đang đợi và thử lại...`);
                    await new Promise(resolve => setTimeout(resolve, 5000)); // Đợi 5 giây trước khi thử lại
                } else {
                    throw error; // Nếu là lỗi khác, thoát vòng lặp và xử lý
                }
            }
        }
    
        if (!isReloaded) {
            console.error(`[${folderName}] [${proxyHost}]Không thể reload trang sau nhiều lần thử.`);
        }
    } catch (error) {
        console.error(`[${folderName}] [${proxyHost}]Lỗi khi reload hoặc kiểm tra dialog:`, error.message);
    }    
}

async function retryProxy(folderName,proxyHost, proxyObj, retryLimit = 10) {
    let isProxyValid = false;
    let retryCount = 0;

    // Kiểm tra proxy ban đầu
    while (!isProxyValid && retryCount < retryLimit) {
        isProxyValid = await checkProxy(proxyObj);
        if (isProxyValid) {
            console.log(`[${folderName}] [${proxyHost}] Proxy hợp lệ.`);
            break;
        } else {
            console.error(`[${folderName}] [${proxyHost}] Proxy không hợp lệ. Thử lại sau 30 giây...`);
            await new Promise(resolve => setTimeout(resolve, 30000)); // Chờ 30 giây
            retryCount++;
        }
    }

    if (!isProxyValid) {
        console.error(`[${folderName}] [${proxyHost}] Proxy không hợp lệ sau ${retryLimit} lần thử. Dừng xử lý profile.`);

        // Đọc proxy từ file nếu proxy không hợp lệ
        const proxyFilePath = path.join(__dirname, 'proxy.txt');
        try {
            const proxies = await loadProxyFromFile(proxyFilePath);
            if (proxies.length === 0) {
                console.error(`[${folderName}] [${proxyHost}] Không có proxy nào trong file proxy.txt.`);
                return;
            }

            // Chọn ngẫu nhiên một proxy từ danh sách
            const randomProxy = proxies[Math.floor(Math.random() * proxies.length)];
            console.log(`[${folderName}] [${proxyHost}] Chọn proxy ngẫu nhiên: ${randomProxy}`);

            // Cập nhật proxyObj với proxy mới và thử lại
            proxyObj = { host: randomProxy }; // Cập nhật đối tượng proxy với proxy mới

            // Tiến hành kiểm tra lại proxy với proxy mới
            await retryProxy(folderName,proxyHost, proxyObj);  // Gọi lại hàm để thử lại
        } catch (error) {
            console.error(`[${folderName}] [${proxyHost}] Lỗi khi đọc proxy từ file:`, error);
        }

        return;
    }

    // Tiến hành công việc khác nếu proxy hợp lệ
    console.log(`[${folderName}] [${proxyHost}] Đã sẵn sàng để tiếp tục.`);
}

async function handleProfileWithProxy(folderName, proxy, url, head, retryLimit) {
    const proxyParts = proxy.match(/^http:\/\/([^:]+):([^@]+)@([^:]+):(\d+)$/);
    if (!proxyParts) {
        console.error(`Proxy "${proxy}" không hợp lệ.`);
        return { browser: null, page: null, proxyHost: null }; // Return proxyHost as well// Trả về null nếu proxy không hợp lệ
    }

    const [_, proxyUsername, proxyPassword, proxyHost, proxyPort] = proxyParts;
    let proxyObj = { host: proxyHost, port: parseInt(proxyPort, 10), username: proxyUsername, password: proxyPassword };

    // Kiểm tra tính hợp lệ của proxy và thay đổi nếu cần
    await retryProxy(folderName, proxyHost, proxyObj, retryLimit);

    const userDataPath = path.join(__dirname, 'profiles', folderName);
    if (!fs.existsSync(userDataPath)) {
        fs.mkdirSync(userDataPath, { recursive: true });
    }

    // Hàm khởi chạy trình duyệt với proxy
    async function launchBrowser(options) {
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                reject(new Error('Timed out while launching browser'));
            }, 30000); // Thời gian chờ tối đa 30 giây

            puppeteer.launch(options).then(browser => {
                clearTimeout(timeout);
                resolve(browser);
            }).catch(err => {
                clearTimeout(timeout);
                reject(err);
            });
        });
    }

    // Hàm retry để thử lại khi có lỗi
    async function retry(fn, retries = 3) {
        let lastError;
        for (let i = 0; i < retries; i++) {
            try {
                return await fn();
            } catch (error) {
                lastError = error;
                console.error(`[${folderName}] [${proxyHost}] Retry ${i + 1} failed: ${error.message}`);
                if (i === retries - 1) {
                    throw lastError;
                }
            }
        }
    }

    try {
        const browser = await retry(() => launchBrowser({
            headless: head,
            args: [
                `--proxy-server=http://${proxyHost}:${proxyPort}`,
                `--user-data-dir=${userDataPath}`,
                '--disable-notifications',
                '--disable-extensions',
                '--no-sandbox',
                '--disable-gpu',
                '--window-size=800,800',
                '--force-device-scale-factor=0.5'
            ],
            defaultViewport: { width: 800, height: 700 }
        }), 3);

        const page = await browser.newPage();

        // Xử lý các cookies và xác thực proxy
        const cookies = await page.cookies();
        for (let cookie of cookies) {
            if (cookie.name === 'proxy-auth-cookie' || cookie.domain === 'proxy.example.com') {
                await page.deleteCookie(cookie);
            }
        }
        console.log(`[${folderName}] [${proxyHost}] Đã xóa các cookie liên quan đến xác thực proxy.`);

        // Xác thực proxy nếu có
        if (proxyUsername && proxyPassword) {
            await page.authenticate({
                username: proxyUsername,
                password: proxyPassword
            });
            console.log(`[${folderName}] [${proxyHost}] Đã xác thực proxy: ${proxyUsername}@${proxyHost}`);
        }

        // Truy cập URL
        await page.goto(url, { waitUntil: 'load', timeout: 60000 });

        // Thêm thông báo tên profile
        await page.evaluate((folderName) => {
            const profileLabel = document.createElement('div');
            profileLabel.style.position = 'fixed';
            profileLabel.style.top = '10px';
            profileLabel.style.right = '10px';
            profileLabel.style.padding = '10px';
            profileLabel.style.backgroundColor = '#fff';
            profileLabel.style.color = '#000';
            profileLabel.style.border = '1px solid #ccc';
            profileLabel.style.fontSize = '16px';
            profileLabel.style.fontWeight = 'bold';
            profileLabel.textContent = `Profile: ${folderName}`;
            profileLabel.style.zIndex = '9999';
            document.body.appendChild(profileLabel);
        }, folderName);

        console.log(`[${folderName}] [${proxyHost}] Xử lý thành công!`);

        // Trả về browser và page sau khi xử lý xong
        return { browser, page, proxyHost };

    } catch (error) {
        if (error.message.includes('Failed to launch the browser process')) {
            console.error(`[${folderName}] [${proxyHost}] Không thể khởi chạy trình duyệt:`, error.message);
        } else if (error.message.includes('net::ERR_INVALID_AUTH_CREDENTIALS')) {
            // Khi gặp lỗi "net::ERR_INVALID_AUTH_CREDENTIALS"
            console.error(`[${folderName}] [${proxyHost}] Lỗi xác thực proxy: ${error.message}`);

            // Lưu lại thông tin vào danh sách lỗi để chạy lại sau (nếu cần thiết)
            failedProfiles.push({ folderName, proxy });

            // Tắt mở lại trình duyệt và xóa xác thực proxy
            try {
                // Đóng trình duyệt hiện tại
                await browser.close();
                console.log(`[${folderName}] [${proxyHost}] Đã đóng trình duyệt vì lỗi xác thực proxy.`);
            } catch (closeError) {
                console.error(`[${folderName}] [${proxyHost}] Lỗi khi đóng trình duyệt: ${closeError.message}`);
            }

            // Tiến hành lại với việc mở trình duyệt mới và xác thực proxy lại
            try {
                const newBrowser = await retry(() => launchBrowser({
                    headless: head,
                    args: [
                        `--proxy-server=http://${proxyHost}:${proxyPort}`,  // Cấu hình proxy
                        `--user-data-dir=${userDataPath}`, // Thư mục dữ liệu người dùng
                        '--disable-notifications',
                        '--disable-extensions',
                        '--no-sandbox',
                        '--disable-gpu',
                        '--window-size=800,800',
                        '--force-device-scale-factor=0.5'
                    ],
                    defaultViewport: { width: 800, height: 700 }
                }), 3);

                console.log(`[${folderName}] [${proxyHost}] Đã mở lại trình duyệt sau khi gặp lỗi xác thực proxy.`);

                // Mở lại trang mới hoặc tiếp tục với quy trình của bạn
                const page = await newBrowser.newPage();
                // Lấy danh sách tất cả cookies
                const cookies = await page.cookies();

                // Xóa tất cả cookies liên quan đến xác thực proxy (giả sử cookie xác thực có tên là 'proxy-auth-cookie')
                for (let cookie of cookies) {
                    // Kiểm tra và xóa các cookie liên quan đến xác thực proxy
                    if (cookie.name === 'proxy-auth-cookie' || cookie.domain === 'proxy.example.com') { // Thay đổi theo tên hoặc domain cookies proxy của bạn
                        await page.deleteCookie(cookie);
                        console.log(`[${folderName}] [${proxyHost}] Đã xóa cookie: ${cookie.name} với domain: ${cookie.domain}`);
                    }
                }
                // Xác thực lại proxy (nếu cần thiết)
                if (proxyUsername && proxyPassword) {
                    await page.authenticate({
                        username: proxyUsername,
                        password: proxyPassword
                    });
                    console.log(`[${folderName}] [${proxyHost}] Đã xác thực lại proxy: ${proxyUsername}@${proxyHost}`);
                }
                // Tiến hành điều hướng và xử lý các bước tiếp theo
                await page.goto(url, { waitUntil: 'load', timeout: 60000 });

                // Trả về browser và page nếu thành công
                return { browser, page, proxyHost };

            } catch (retryError) {
                console.error(`[${folderName}] [${proxyHost}] Lỗi khi mở lại trình duyệt:`, retryError.message);
                // Lưu vào danh sách lỗi để thực hiện lại sau nếu cần
                failedProfiles.push({ folderName, proxy });
            }
        } else {
            // Xử lý các lỗi khác
            console.error(`[${folderName}] [${proxyHost}] Lỗi không xác định:`, error.message);
            failedProfiles.push({ folderName, proxy });
        }

        // Trả về null nếu có lỗi
        return { browser: null, page: null, proxyHost: proxyHost };
    }
}


async function processIframeDetection(browser, page, folderName, proxyHost, elementSelector, dataFilePath, logoutError) {
    let confirmClicked = false;
    let iframeDetected = false;
    let retryAttempts = 0;
    let reloadAttempts = 0;
    let loopAttempts = 0;
    const maxRetries = 5;
    const maxReloads = 5;
    const maxLoopAttempts = 20;

    while (!iframeDetected) {
        try {
            loopAttempts++; // Tăng biến đếm số vòng lặp

            // Kiểm tra số lần lặp đã vượt quá giới hạn chưa
            if (loopAttempts > maxLoopAttempts) {
                console.log(`[${folderName}] [${proxyHost}] Đã đạt số vòng lặp tối đa (${maxLoopAttempts}). Thoát để tránh chạy vô hạn.`);
                if (browser && browser.isConnected()) {
                    await browser.close();
                }
                break; // Thoát vòng lặp
            }

            try {
                console.log(`[${folderName}] [${proxyHost}] Đang chờ phần tử button[class="Button tiny primary fluid has-ripple"]...`);
                await page.waitForSelector('button[class="Button tiny primary fluid has-ripple"]', { visible: true, timeout: 5000 });
                await new Promise(resolve => setTimeout(resolve, 2000)); // Thêm thời gian chờ trước khi click
                console.log(`[${folderName}] [${proxyHost}] Tìm thấy phần tử button[class="Button tiny primary fluid has-ripple"]! Đang click...`);
                await page.click('button[class="Button tiny primary fluid has-ripple"]');
            } catch (error) {
                if (error.name === 'TimeoutError') {
                    console.log(`[${folderName}] [${proxyHost}] Không tìm thấy phần tử button[class="Button tiny primary fluid has-ripple"]. Tiếp tục.`); 
                } else {
                    console.error(`[${folderName}] [${proxyHost}] Lỗi khi xử lý phần tử:`, error.message);
                }
            }

            console.log(`[${folderName}] [${proxyHost}] Đang chờ phần tử "${elementSelector}"...`);
            await page.waitForSelector(elementSelector, { visible: true });
            await new Promise(resolve => setTimeout(resolve, 2000)); // Thêm thời gian chờ trước khi click
            console.log(`[${folderName}] [${proxyHost}] Tìm thấy phần tử "${elementSelector}". Đang click...`);
            await page.click(elementSelector);

            // Chờ nút "Confirm"
            console.log(`[${folderName}] [${proxyHost}] Đang chờ nút "Confirm"...`);
            await page.waitForSelector('button.Button.confirm-dialog-button.default.primary.text', { timeout: 5000 });
            await new Promise(resolve => setTimeout(resolve, 2000)); 
            console.log(`[${folderName}] [${proxyHost}] Tìm thấy nút "Confirm". Đang click...`);
            await page.click('button.Button.confirm-dialog-button.default.primary.text');

            // Kiểm tra iframe
            console.log(`[${folderName}] [${proxyHost}] Chờ để kiểm tra iframe...`);
            await page.waitForSelector('iframe', { timeout: 10000 }); // Chờ tối đa 10 giây
            const iframe = await page.$('iframe');
            
            if (iframe) {
                console.log(`[${folderName}] [${proxyHost}] Iframe đã xuất hiện!`);
                const iframeSrc = await page.evaluate(iframe => iframe.src, iframe);
                if (!iframeSrc || iframeSrc.trim() === '') {
                    console.log(`[${folderName}] [${proxyHost}] Src của iframe trống hoặc không hợp lệ. Reload lại trang.`);
                    await reloadPage(folderName, proxyHost);
                    retryAttempts = 0;
                    reloadAttempts++;
                    if (reloadAttempts >= maxReloads) {
                        console.log(`[${folderName}] [${proxyHost}] Đã reload ${maxReloads} lần mà không thấy iframe. Thoát.`);
                        logoutError.push(`Profile: ${folderName} - Không tìm thấy Iframe.`);
                        await browser.close();
                        break;
                    }
                } else {
                    iframeDetected = true;
                    const query_id = extractUserData(iframeSrc);
                    console.log(`[${folderName}] [${proxyHost}] query_id của iframe: ${query_id}`);
                    fs.appendFileSync(dataFilePath, `${query_id}\n`, 'utf-8');
                    console.log(`[${folderName}] [${proxyHost}] Đã ghi query_id vào file: ${dataFilePath}`);
                    await browser.close();
                    console.log(`[${folderName}] [${proxyHost}] Đã đóng trình duyệt cho profile: ${folderName}`);
                }
            } else {
                console.log(`[${folderName}] [${proxyHost}] Iframe chưa xuất hiện. Quay lại click nút "Play".`);

                // Kiểm tra đăng xuất
                const loginElement = await page.$('h1');
                if (loginElement) {
                    const textContent = await page.evaluate(element => element.textContent, loginElement);
                    if (textContent.includes('Log in to Telegram by QR Code')) {
                        console.log(`[${folderName}] [${proxyHost}] Đã đăng xuất khỏi Telegram. Chuyển qua profile khác.`);
                        logoutError.push(`Profile: ${folderName} - Đã đăng xuất khỏi Telegram`);
                        await browser.close();
                        break;
                    }
                }

                retryAttempts++;
                if (retryAttempts >= maxRetries) {
                    console.log(`[${folderName}] [${proxyHost}] Đã thử ${maxRetries} lần mà không thấy iframe. Reload lại trang.`);
                    await reloadPage(folderName, proxyHost);
                    retryAttempts = 0;
                    reloadAttempts++;
                    if (reloadAttempts >= maxReloads) {
                        console.log(`[${folderName}] [${proxyHost}] Đã reload ${maxReloads} lần mà không thấy iframe. Thoát.`);
                        logoutError.push(`Profile: ${folderName} - Không tìm thấy Iframe.`);
                        await browser.close();
                        break;
                    }
                }
            }
        } catch (err) {
            if (err.name === 'TimeoutError') {
                console.log(`[${folderName}] [${proxyHost}] Nút "Confirm" không xuất hiện. Kiểm tra iframe...`);
                try {
                    const loginElement = await page.$('h1');
                    if (loginElement) {
                        const textContent = await page.evaluate(element => element.textContent, loginElement);
                        if (textContent.includes('Log in to Telegram by QR Code')) {
                            console.log(`[${folderName}] [${proxyHost}] Đã đăng xuất khỏi Telegram. Chuyển qua profile khác.`);
                            logoutError.push(`Profile: ${folderName} - Đã đăng xuất khỏi Telegram`);
                            await browser.close();
                            break;
                        }
                    }

                    await page.waitForSelector('iframe', { timeout: 10000 });
                    const iframe = await page.$('iframe');
                    if (iframe) {
                        const iframeSrc = await page.evaluate(iframe => iframe.src, iframe);
                        if (!iframeSrc || iframeSrc.trim() === '') {
                            console.log(`[${folderName}] [${proxyHost}] Src của iframe trống hoặc không hợp lệ. Reload lại trang.`);
                            await reloadPage(folderName, proxyHost);
                            retryAttempts = 0;
                            reloadAttempts++;
                            if (reloadAttempts >= maxReloads) {
                                console.log(`[${folderName}] [${proxyHost}] Đã reload ${maxReloads} lần mà không thấy iframe. Thoát.`);
                                await browser.close();
                                break;
                            }
                        } else {
                            iframeDetected = true;
                            const query_id = extractUserData(iframeSrc);
                            console.log(`[${folderName}] [${proxyHost}] query_id của iframe: ${query_id}`);
                            fs.appendFileSync(dataFilePath, `${query_id}\n`, 'utf-8');
                            await browser.close();
                            console.log(`[${folderName}] [${proxyHost}] Đã đóng trình duyệt cho profile: ${folderName}`);
                        }
                    }
                } catch (error) {
                    await reloadPage(folderName, proxyHost);
                }
            } else {
                console.error(`[${folderName}] [${proxyHost}] Lỗi khác xảy ra:`, err);
                logoutError.push(`Profile: ${folderName} - Lỗi: ${err.message}`);
                if (browser && browser.isConnected()) {
                    await browser.close();
                }
                break;
            }
        }
    }
}

const processProfile = async ({ folderName, proxy }, { url, elementSelector, dataFilePath, showBrowser }) => {
    console.log(`[${folderName}] Bắt đầu xử lý profile với proxy: ${proxy}`);
    const retryLimit = 10;
    const head = Number(showBrowser) === 1 ? false : true;

    let browser, page, proxyHost; // Declare browser, page, and proxyHost variables

    try {
        // Destructure to get proxyHost from handleProfileWithProxy return
        const result = await handleProfileWithProxy(folderName, proxy, url, head, retryLimit);
        browser = result.browser;
        page = result.page;
        proxyHost = result.proxyHost;

        console.log(browser, page, proxyHost);

        if (!browser || !page || !proxyHost) {
            console.error(`[${folderName}] Không thể kết nối với proxy.`);
            logoutError.push(`Profile: ${folderName} - Không thể kết nối với proxy.`);
            
            // Close browser if it's opened before returning
            if (browser && browser.isConnected()) {
                try {
                    await browser.close();
                    console.log(`[${folderName}] Đã đóng trình duyệt do lỗi kết nối proxy.`);
                } catch (closeError) {
                    console.error(`[${folderName}] Lỗi khi đóng trình duyệt: ${closeError.message}`);
                }
            }
            return; // Early return if no proxy connection
        }

        console.log(`[${folderName}] Đã kết nối với proxy thành công.`.green);

        // Proceed with iframe detection
        await processIframeDetection(browser, page, folderName, proxyHost, elementSelector, dataFilePath, logoutError);
        console.log(`[${folderName}] Đã hoàn thành quá trình xử lý iframe.`.bgGreen);

    } catch (error) {
        console.error(`[${folderName}] Xảy ra lỗi khi xử lý profile:`, error);
        logoutError.push(`Profile: ${folderName} - Lỗi: ${error.message}`);

        // Ensure browser is closed in case of error
        if (browser && browser.isConnected()) {
            try {
                await browser.close();
                console.log(`[${folderName}] Đã đóng trình duyệt do lỗi.`);
            } catch (closeError) {
                console.error(`[${folderName}] Lỗi khi đóng trình duyệt: ${closeError.message}`);
            }
        }
    }
};



async function retryFailedProfiles(failedProfiles,url, elementSelector,dataFilePath,theard,showBrowser) {
    if (failedProfiles.length > 0) {
        console.log(`Thử lại ${failedProfiles.length} profile gặp lỗi...`.bgMagenta);

        // Chạy lại các tác vụ với async.eachLimit để giới hạn số lượng tác vụ chạy đồng thời
        await new Promise((resolve, reject) => {
            async.eachLimit(failedProfiles, theard, async (profile) => {
                try {
                    // Xử lý lại mỗi profile bị lỗi
                    await processProfile(profile, { url, elementSelector, dataFilePath, showBrowser });
                    console.log(`[${profile.folderName}] [${profile.proxy}] Đã xử lý lại thành công`.blue);
                } catch (err) {
                    console.error(`[${profile.folderName}] [${profile.proxy}] Xử lý lại gặp lỗi: ${err.message}`);
                }
            }, (err) => {
                if (err) {
                    reject(err); // Nếu có lỗi trong khi xử lý, reject promise
                } else {
                    resolve(); // Nếu không có lỗi, resolve promise
                }
            });
        });
    } else {
        console.log('Không có profile nào để thử lại.');
    }
}

const run = async () => {
    try{
        const gameData = fs.readFileSync('ini/select_game.txt', 'utf-8').split('\n').map(line => line.trim()).filter(Boolean);

        if (gameData.length === 0) {
            console.error('Không có dữ liệu trong file select_game.txt');
            return;
        }

        const [nameTask, url, elementSelector, dataFilePath,theard,showBrowser] = gameData[0].split('|');
        //console.log('showBrowser: ',showBrowser)
        fs.writeFileSync(dataFilePath, '', 'utf-8'); // Xóa dữ liệu cũ
        const profiles = readProfilesFromFile();

        //MAX_PARALLEL_PROFILES = theard
        
        // Sử dụng async.eachLimit để giới hạn số lượng tác vụ chạy đồng thời
        await new Promise((resolve, reject) => {
            async.eachLimit(profiles, theard, async (profile) => {
                await processProfile(profile, { url, elementSelector, dataFilePath,showBrowser });
            }, (err) => {
                if (err) {
                    reject(err);
                } else {
                    resolve();
                }
            });
        });

        await retryFailedProfiles(failedProfiles,url, elementSelector, dataFilePath,theard,showBrowser); 

        if (logoutError.length > 0) {
            const bom = '\uFEFF'; // BOM cho UTF-8
            const dataWithTaskName = logoutError.map(line => `${nameTask}: ${line}`).join('\n'); // Thêm nameTask vào đầu mỗi dòng

            // Kiểm tra nếu tệp chưa tồn tại, thêm BOM
            fs.access('ini/LogOut.txt', fs.constants.F_OK, (err) => {
                const initialContent = err ? bom : ''; // Nếu tệp chưa tồn tại, thêm BOM
                const contentToAppend = initialContent + dataWithTaskName + '\n';

                // Ghi thêm dữ liệu vào file
                fs.appendFile('ini/LogOut.txt', contentToAppend, (err) => {
                    if (err) {
                        console.error('Lỗi khi ghi lỗi vào file:', err);
                    } else {
                        console.log('Đã ghi thêm lỗi vào file: ini/LogOut.txt');
                    }
                });
            });
        } else {
            console.log('Không có lỗi nào cần ghi ra file.');
        }

        console.log(`Hoàn thành ${countProfile} profile.`);
        await new Promise(resolve => setTimeout(resolve, 5000)); 
    }catch(error) {
        console.error(` Lỗi với": `, error.message);
        await new Promise(resolve => setTimeout(resolve, 5000)); 
    }
};

run();
