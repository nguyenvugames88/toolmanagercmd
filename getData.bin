const puppeteer = require('puppeteer');
const path = require('path');
const fs = require('fs');
const { HttpsProxyAgent } = require('https-proxy-agent');
const axios = require('axios');
const async = require('async');
const colors = require('colors');

let countProfile = 0
const MAX_PARALLEL_PROFILES = 10; // Giới hạn số profile chạy đồng thời

// Hàm sleep để tạm dừng
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
const failedProfiles = [];
const logoutError = [];
// Đọc danh sách profile và proxy từ file TXT
const readProfilesFromFile = () => {
    const filePath = path.join(__dirname, 'SelectedAllProfiles.txt');
    if (!fs.existsSync(filePath)) {
        console.error('File SelectedAllProfiles.txt không tồn tại.');
        process.exit(1);
    }
    const lines = fs.readFileSync(filePath, 'utf-8').split('\n').map(line => line.trim()).filter(Boolean);
    return lines.map(line => {
        const parts = line.split('|');
        return { folderName: parts[0], proxy: parts[1] };
    });
};

// Kiểm tra proxy
const checkProxy = async (proxy) => {
    try {
        const agent = new HttpsProxyAgent(`http://${proxy.username}:${proxy.password}@${proxy.host}:${proxy.port}`);
        const response = await axios.get('https://httpbin.org/ip', { httpsAgent: agent });
        console.log('Proxy hoạt động:', response.data);
        return true;
    } catch (error) {
        console.error('Lỗi proxy:', error.message);
        return false;
    }
};

// Trích xuất thông tin từ URL iframe
const extractUserData = (url) => {
    let result = '';
    const queryStartIndex = url.indexOf('query_id%3D');
    if (queryStartIndex !== -1) {
        const queryEndIndex = url.indexOf('&', queryStartIndex);
        result = 'query_id=' + url.substring(queryStartIndex + 'query_id%3D'.length, queryEndIndex === -1 ? url.length : queryEndIndex);
    } else {
        const userStartIndex = url.indexOf('user%3D');
        if (userStartIndex !== -1) {
            const userEndIndex = url.indexOf('&', userStartIndex);
            result = 'user=' + url.substring(userStartIndex + 'user%3D'.length, userEndIndex === -1 ? url.length : userEndIndex);
        }
    }
    return result.replace(/%3D/g, '=').replace(/%25/g, '%').replace(/%26/g, '&') || '0';
};

async function checkAndDismissDialog(page) {
    try {
        const dialogs = await page.$$('dialog');  // Kiểm tra tất cả các hộp thoại (dialog) đang mở

        if (dialogs.length > 0) {
            console.log("Dialog found! Đang tắt dialog...");
            for (let dialog of dialogs) {
                // Đóng tất cả các dialog nếu có
                await dialog.evaluate(dialog => dialog.close());
            }
        } else {
            console.log("Không có dialog nào mở.");
        }
    } catch (error) {
        console.error("Lỗi khi kiểm tra hoặc đóng dialog:", error.message);
    }
}

async function reloadPage(folderName,proxyHost) {
    try {
        let retryCount = 0;
        const maxRetries = 5; // Số lần thử reload tối đa
        let isReloaded = false;
    
        while (!isReloaded && retryCount < maxRetries) {
            try {
                retryCount++;
                console.log(`[${folderName}] [${proxyHost}][Retry ${retryCount}] Đang reload trang...`);
                await page.reload({ waitUntil: 'networkidle0' }); // Đợi khi không còn kết nối mạng nào
    
                // Nếu reload thành công, đặt trạng thái isReloaded = true
                isReloaded = true;
                console.log(`[${folderName}] [${proxyHost}]Đã reload thành công và kiểm tra dialog.`);
            } catch (error) {
                console.error(`[Retry ${retryCount}] Lỗi khi reload: ${error.message}`);
    
                if (error.message.includes("Navigation timeout")) {
                    console.log(`[${folderName}] [${proxyHost}]Navigation timeout xảy ra, đang đợi và thử lại...`);
                    await new Promise(resolve => setTimeout(resolve, 5000)); // Đợi 5 giây trước khi thử lại
                } else {
                    throw error; // Nếu là lỗi khác, thoát vòng lặp và xử lý
                }
            }
        }
    
        if (!isReloaded) {
            console.error(`[${folderName}] [${proxyHost}]Không thể reload trang sau nhiều lần thử.`);
        }
    } catch (error) {
        console.error(`[${folderName}] [${proxyHost}]Lỗi khi reload hoặc kiểm tra dialog:`, error.message);
    }    
}

async function retryProxy(folderName,proxyHost, proxyObj, retryLimit = 10) {
    let isProxyValid = false;
    let retryCount = 0;

    // Kiểm tra proxy ban đầu
    while (!isProxyValid && retryCount < retryLimit) {
        isProxyValid = await checkProxy(proxyObj);
        if (isProxyValid) {
            console.log(`[${folderName}] [${proxyHost}] Proxy hợp lệ.`);
            break;
        } else {
            console.error(`[${folderName}] [${proxyHost}] Proxy không hợp lệ. Thử lại sau 30 giây...`);
            await new Promise(resolve => setTimeout(resolve, 30000)); // Chờ 30 giây
            retryCount++;
        }
    }

    if (!isProxyValid) {
        console.error(`[${folderName}] [${proxyHost}] Proxy không hợp lệ sau ${retryLimit} lần thử. Dừng xử lý profile.`);

        // Đọc proxy từ file nếu proxy không hợp lệ
        const proxyFilePath = path.join(__dirname, 'proxy.txt');
        try {
            const proxies = await loadProxyFromFile(proxyFilePath);
            if (proxies.length === 0) {
                console.error(`[${folderName}] [${proxyHost}] Không có proxy nào trong file proxy.txt.`);
                return;
            }

            // Chọn ngẫu nhiên một proxy từ danh sách
            const randomProxy = proxies[Math.floor(Math.random() * proxies.length)];
            console.log(`[${folderName}] [${proxyHost}] Chọn proxy ngẫu nhiên: ${randomProxy}`);

            // Cập nhật proxyObj với proxy mới và thử lại
            proxyObj = { host: randomProxy }; // Cập nhật đối tượng proxy với proxy mới

            // Tiến hành kiểm tra lại proxy với proxy mới
            await retryProxy(folderName,proxyHost, proxyObj);  // Gọi lại hàm để thử lại
        } catch (error) {
            console.error(`[${folderName}] [${proxyHost}] Lỗi khi đọc proxy từ file:`, error);
        }

        return;
    }

    // Tiến hành công việc khác nếu proxy hợp lệ
    console.log(`[${folderName}] [${proxyHost}] Đã sẵn sàng để tiếp tục.`);
}
const processProfile = async ({ folderName, proxy }, { url, elementSelector, dataFilePath,showBrowser }) => {
    const retryLimit = 10; // Số lần retry tối đa khi proxy không hợp lệ

    // Tách thông tin proxy
    const proxyParts = proxy.match(/^http:\/\/([^:]+):([^@]+)@([^:]+):(\d+)$/);
    if (!proxyParts) {
        console.error(`Proxy "${proxy}" không hợp lệ.`);
        return; // Dừng ngay nếu proxy không hợp lệ
    }

    const [_, proxyUsername, proxyPassword, proxyHost, proxyPort] = proxyParts;
    const proxyObj = { host: proxyHost, port: parseInt(proxyPort, 10), username: proxyUsername, password: proxyPassword };

    retryProxy(folderName,proxyHost,proxyObj,retryLimit)
    let browser  ,retry ,launchBrowser,userDataPath
    const head = Number(showBrowser) === 1 ? false : true;
    const proxyAuthURL = `http://${proxyHost}:${proxyPort}`;
    // Xử lý profile khi proxy hợp lệ
    try {
        console.log(`[${folderName}] [${proxyHost}] Đang xử lý profile: ${folderName}`.magenta);

        userDataPath = path.join(__dirname, 'profiles', folderName);
        if (!fs.existsSync(userDataPath)) {
            fs.mkdirSync(userDataPath, { recursive: true });
        }
        
        launchBrowser = async (options) => {
            return new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    reject(new Error('Timed out while launching browser'));
                }, 30000); // Thời gian chờ tối đa 30 giây

                puppeteer.launch(options).then(browser => {
                    clearTimeout(timeout);
                    resolve(browser);
                }).catch(err => {
                    clearTimeout(timeout);
                    reject(err);
                });
            });
        };

        retry = async (fn, retries = 3) => {
            for (let i = 0; i < retries; i++) {
                try {
                    return await fn();
                } catch (err) {
                    console.log(`[${folderName}] [${proxyHost}]Thử lần ${i + 1} thất bại: ${err.message}`);
                    if (i === retries - 1) throw err;
                }
            }
        };
        
        
        //console.log('head: ', head);

        browser = await retry(() => launchBrowser({
            headless: head,
            args: [
                `--proxy-server=${proxyAuthURL}`,  // Cấu hình proxy
                `--user-data-dir=${userDataPath}`, // Thư mục dữ liệu người dùng
                '--disable-notifications',
                '--disable-extensions',
                '--no-sandbox',
                '--disable-gpu',
                '--window-size=800,800',
                '--force-device-scale-factor=0.5'
            ],
            defaultViewport: { width: 800, height: 700 }
        }), 3);

        // Mở một trang trình duyệt mới
        const page = await browser.newPage();

        // Lấy danh sách tất cả cookies
        const cookies = await page.cookies();

        // Xóa tất cả cookies liên quan đến xác thực proxy (giả sử cookie xác thực có tên là 'proxy-auth-cookie')
        for (let cookie of cookies) {
            // Kiểm tra và xóa các cookie liên quan đến xác thực proxy
            if (cookie.name === 'proxy-auth-cookie' || cookie.domain === 'proxy.example.com') { // Thay đổi theo tên hoặc domain cookies proxy của bạn
                await page.deleteCookie(cookie);
            }
        }

        // Xác thực proxy (nếu cần thiết)
        if (proxyUsername && proxyPassword) {
            await page.authenticate({
                username: proxyUsername,
                password: proxyPassword
            });
            console.log(`[${folderName}] [${proxyHost}] Đã xác thực proxy: ${proxyUsername}@${proxyHost}`);
        }

        // Điều hướng đến URL cần thiết
        await page.goto(url, { waitUntil: 'load', timeout: 60000 });


        // Thêm thông báo tên profile
        await page.evaluate((folderName) => {
            const profileLabel = document.createElement('div');
            profileLabel.style.position = 'fixed';
            profileLabel.style.top = '10px';
            profileLabel.style.right = '10px';
            profileLabel.style.padding = '10px';
            profileLabel.style.backgroundColor = '#fff';
            profileLabel.style.color = '#000';
            profileLabel.style.border = '1px solid #ccc';
            profileLabel.style.fontSize = '16px';
            profileLabel.style.fontWeight = 'bold';
            profileLabel.textContent = `Profile: ${folderName}`;
            profileLabel.style.zIndex = '9999';
            document.body.appendChild(profileLabel);
        }, folderName);

        let confirmClicked = false;
        let iframeDetected = false;
        let retryAttempts = 0;
        let reloadAttempts = 0;
        let loopAttempts = 0; // Biến đếm số lần lặp
        const maxRetries = 5; // Số lần thử click tối đa
        const maxReloads = 5; // Số lần reload tối đa
        const maxLoopAttempts = 20; // Số vòng lặp tối đa để tránh chạy vô hạn

        while (!iframeDetected) {
            try {
                loopAttempts++; // Tăng biến đếm số vòng lặp

                // Kiểm tra số lần lặp đã vượt quá giới hạn chưa
                if (loopAttempts > maxLoopAttempts) {
                    console.log(`[${folderName}] [${proxyHost}] Đã đạt số vòng lặp tối đa (${maxLoopAttempts}). Thoát để tránh chạy vô hạn.`.bgRed);
                    if (browser && browser.isConnected()) {
                        await browser.close();
                    }
                    break; // Thoát vòng lặp
                }

                try {
                    console.log(`[${folderName}] [${proxyHost}] Đang chờ phần tử "${elementSelector}"...`);
                    await page.waitForSelector(elementSelector, { visible: true });
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    console.log(`[${folderName}] [${proxyHost}] Tìm thấy phần tử "${elementSelector}". Đang click...`.blue);
            
                    await page.click(elementSelector); // Thử click vào phần tử
                } catch (error) {
                    console.error(`[${folderName}] [${proxyHost}] Không tìm thấy phần tử "${elementSelector}".`, error.message);
            
                    try {
                        // Gõ "/start" vào div có id="editable-message-text"
                        console.log(`[${folderName}] [${proxyHost}] Đang nhập "/start" vào div[id="editable-message-text"]...`);
                        await page.type('div[id="editable-message-text"]', '/start');
                        await page.keyboard.press('Enter'); // Nhấn Enter
            
                        // Chờ một chút trước khi tìm lại
                        console.log(`[${folderName}] [${proxyHost}] Đợi một lát trước khi tìm lại phần tử "${elementSelector}"...`);
                        await new Promise(resolve => setTimeout(resolve, 2000));
            
                        // Tìm lại phần tử
                        console.log(`[${folderName}] [${proxyHost}] Đang tìm lại phần tử "${elementSelector}"...`);
                        await page.waitForSelector(elementSelector, { visible: true });
                        console.log(`[${folderName}] [${proxyHost}] Tìm thấy phần tử "${elementSelector}". Đang click...`.blue);
            
                        await page.click(elementSelector); // Thử click lại
                    } catch (retryError) {
                        console.error(`[${folderName}] [${proxyHost}] Lỗi khi retry với phần tử "${elementSelector}":`, retryError.message);
            
                        // Reload trang nếu vẫn thất bại
                        try {
                            console.log(`[${folderName}] [${proxyHost}] Đang reload trang...`);
                            await page.reload({ waitUntil: 'networkidle0' }); // Đợi đến khi mạng ổn định
            
                            console.log(`[${folderName}] [${proxyHost}] Đã reload trang. Đang tìm lại phần tử "${elementSelector}"...`);
                            await page.waitForSelector(elementSelector, { visible: true, timeout: 5000 }); // Chờ thêm một chút để tìm phần tử
            
                            console.log(`[${folderName}] [${proxyHost}] Tìm thấy phần tử "${elementSelector}". Đang click...`.blue);
                            await page.click(elementSelector); // Thử click sau reload
                        } catch (reloadError) {
                            console.error(`[${folderName}] [${proxyHost}] Không tìm thấy phần tử "${elementSelector}" sau khi reload:`, reloadError.message);
            
                            // Kiểm tra nếu tồn tại phần tử với aria-label="Text not allowed"
                            const textNotAllowedSelector = 'div[aria-label="Text not allowed"]';
                            const isTextNotAllowed = await page.$(textNotAllowedSelector);
            
                            if (isTextNotAllowed) {
                                console.error(`[${folderName}] [${proxyHost}] Chưa chạy Ref cho tài khoản Telegram.`);
                                logoutError.push(`Profile: ${folderName} - Chưa Ref cho Telegram này`); // Lưu lỗi
                                if (browser && browser.isConnected()) {
                                    await browser.close();
                                }
                                break; // Thoát vòng lặp
                            } else {
                                console.error(`[${folderName}] [${proxyHost}] Phần tử "${elementSelector}" vẫn không tìm thấy sau khi reload.`);
                                logoutError.push(`Profile: ${folderName} - Phần tử "${elementSelector}" vẫn không tìm thấy`); // Lưu lỗi
                                if (browser && browser.isConnected()) {
                                    await browser.close();
                                }
                                break; // Thoát vòng lặp
                            }
                        }
                    }
                }

                console.log(`[${folderName}] [${proxyHost}] Đang chờ nút "Confirm"...`);
                await page.waitForSelector('button.Button.confirm-dialog-button.default.primary.text', { timeout: 5000 });
                await new Promise(resolve => setTimeout(resolve, 2000)); // Thêm thời gian chờ trước khi click
                console.log(`[${folderName}] [${proxyHost}] Tìm thấy nút "Confirm". Đang click...`.blue);

                try {
                    await page.click('button.Button.confirm-dialog-button.default.primary.text');
                } catch (error) {
                    console.error("Error interacting with element:", error);
                    await reloadPage(folderName,proxyHost)
                }

                console.log(`[${folderName}] [${proxyHost}] Chờ để kiểm tra iframe...`);
                try {
                    await page.waitForSelector('iframe', { timeout: 10000 }); // Chờ tối đa 10 giây
                    const iframe = await page.$('iframe');

                    if (iframe) {
                        console.log(`[${folderName}] [${proxyHost}] Iframe đã xuất hiện!`.green);
                        const iframeSrc = await page.evaluate(iframe => iframe.src, iframe);
                        if (!iframeSrc || iframeSrc.trim() === '') {  // Kiểm tra iframeSrc không có dữ liệu
                            console.log(`[${folderName}] [${proxyHost}] Src của iframe trống hoặc không hợp lệ. Reload lại trang.`.yellow);
                            await reloadPage(folderName,proxyHost)
                            retryAttempts = 0;
                            reloadAttempts++;
                            if (reloadAttempts >= maxReloads) {
                                console.log(`[${folderName}] [${proxyHost}] Đã reload ${maxReloads} lần mà không thấy iframe. Thoát.`.bgRed);
                                logoutError.push(`Profile: ${folderName} - Không tìm thấy Iframe.`); // Lưu lỗi
                                if (browser && browser.isConnected()) {
                                    await browser.close();
                                }
                                break; // Thoát vòng lặp
                            }
                        } else {
                            iframeDetected = true;
                            countProfile++
                            const query_id = extractUserData(iframeSrc);
                            console.log(`[${folderName}] [${proxyHost}] query_id của iframe: ${query_id}`.green);

                            fs.appendFileSync(dataFilePath, `${query_id}\n`, 'utf-8');
                            console.log(`[${folderName}] [${proxyHost}] Đã ghi query_id vào file: ${dataFilePath}`.green);

                            await browser.close();
                            console.log(`[${folderName}] [${proxyHost}] Đã đóng trình duyệt cho profile: ${folderName}`.green);
                        }
                    } else {
                        console.log(`[${folderName}] [${proxyHost}] Iframe chưa xuất hiện. Quay lại click nút "Play".`.yellow);

                        // Kiểm tra đăng xuất
                        const loginElement = await page.$('h1');
                        if (loginElement) {
                            const textContent = await page.evaluate(element => element.textContent, loginElement);
                            if (textContent.includes('Log in to Telegram by QR Code')) {
                                console.log(`[${folderName}] [${proxyHost}] Đã đăng xuất khỏi Telegram. Chuyển qua profile khác.`.red);
                                logoutError.push(`Profile: ${folderName} - Đã đăng xuất khỏi Telegram`); // Lưu lỗi
                                await browser.close();
                                break; // Thoát vòng lặp để chuyển qua profile khác
                            }
                        }

                        retryAttempts++;
                        if (retryAttempts >= maxRetries) {
                            console.log(`[${folderName}] [${proxyHost}] Đã thử ${maxRetries} lần mà không thấy iframe. Reload lại trang.`.bgYellow);
                            await reloadPage(folderName,proxyHost)
                            retryAttempts = 0;
                            reloadAttempts++;

                            if (reloadAttempts >= maxReloads) {
                                console.log(`[${folderName}] [${proxyHost}] Đã reload ${maxReloads} lần mà không thấy iframe. Thoát.`.bgRed);
                                logoutError.push(`Profile: ${folderName} - Không tìm thấy Iframe.`); // Lưu lỗi
                                if (browser && browser.isConnected()) {
                                    await browser.close();
                                }
                                break; // Thoát vòng lặp
                            }
                        }
                    }
                } catch (error) {
                    console.error(`[${folderName}] [${proxyHost}] Lỗi khi chờ iframe:`, error.message,'Reload lại trang. ');
                    try {
                        // Kiểm tra đăng xuất
                        const loginElement = await page.$('h1');
                        if (loginElement) {
                            const textContent = await page.evaluate(element => element.textContent, loginElement);
                            if (textContent.includes('Log in to Telegram by QR Code')) {
                                console.log(`[${folderName}] [${proxyHost}] Đã đăng xuất khỏi Telegram. Chuyển qua profile khác.`.red);
                                logoutError.push(`Profile: ${folderName} - Đã đăng xuất khỏi Telegram`); // Lưu lỗi
                                await browser.close();
                                break; // Thoát vòng lặp để chuyển qua profile khác
                            }
                        }                     
                    } catch (error) {
                        await reloadPage(folderName,proxyHost)
                    }
                    reloadAttempts++;
                    if (reloadAttempts >= maxReloads) {
                        console.log(`[${folderName}] [${proxyHost}] Đã reload ${maxReloads} lần mà không thấy iframe. Thoát.`.bgRed);
                        if (browser && browser.isConnected()) {
                            await browser.close();
                        }
                        break; // Thoát vòng lặp
                    }
                }
            } catch (err) {
                if (err.name === 'TimeoutError') {
                    console.log(`[${folderName}] [${proxyHost}] Nút "Confirm" không xuất hiện. Kiểm tra iframe...`.yellow);
                    try {
                        // Kiểm tra đăng xuất
                        const loginElement = await page.$('h1');
                        if (loginElement) {
                            const textContent = await page.evaluate(element => element.textContent, loginElement);
                            if (textContent.includes('Log in to Telegram by QR Code')) {
                                console.log(`[${folderName}] [${proxyHost}] Đã đăng xuất khỏi Telegram. Chuyển qua profile khác.`.red);
                                logoutError.push(`Profile: ${folderName} - Đã đăng xuất khỏi Telegram`); // Lưu lỗi
                                await browser.close();
                                break; // Thoát vòng lặp để chuyển qua profile khác
                            }
                        }
                        await page.waitForSelector('iframe', { timeout: 10000 }); // Chờ tối đa 10 giây
                        const iframe = await page.$('iframe');
                        if (iframe) {
                            console.log(`[${folderName}] [${proxyHost}] Iframe đã xuất hiện!`.green);
                            const iframeSrc = await page.evaluate(iframe => iframe.src, iframe);
                            if (!iframeSrc || iframeSrc.trim() === '') {  // Kiểm tra iframeSrc không có dữ liệu
                                console.log(`[${folderName}] [${proxyHost}] Src của iframe trống hoặc không hợp lệ. Reload lại trang.`.yellow);
                                await reloadPage(folderName,proxyHost)
                                retryAttempts = 0;
                                reloadAttempts++;
                                if (reloadAttempts >= maxReloads) {
                                    console.log(`[${folderName}] [${proxyHost}] Đã reload ${maxReloads} lần mà không thấy iframe. Thoát.`.bgRed);
                                    if (browser && browser.isConnected()) {
                                        await browser.close();
                                    }
                                    break; // Thoát vòng lặp
                                }
                            } else {
                                iframeDetected = true;
                                countProfile++
                                const query_id = extractUserData(iframeSrc);
                                console.log(`[${folderName}] [${proxyHost}] query_id của iframe: ${query_id}`.green);

                                fs.appendFileSync(dataFilePath, `${query_id}\n`, 'utf-8');
                                console.log(`[${folderName}] [${proxyHost}] Đã ghi query_id vào file: ${dataFilePath}`.green);

                                await browser.close();
                                console.log(`[${folderName}] [${proxyHost}] Đã đóng trình duyệt cho profile: ${folderName}`.green);
                            }
                        } else {
                            console.log(`[${folderName}] [${proxyHost}] Iframe chưa xuất hiện. Quay lại click nút "Play".`.yellow);

                            // Kiểm tra đăng xuất
                            const loginElement = await page.$('h1');
                            if (loginElement) {
                                const textContent = await page.evaluate(element => element.textContent, loginElement);
                                if (textContent.includes('Log in to Telegram by QR Code')) {
                                    console.log(`[${folderName}] [${proxyHost}] Đã đăng xuất khỏi Telegram. Chuyển qua profile khác.`.red);
                                    logoutError.push(`Profile: ${folderName} - Đã đăng xuất khỏi Telegram`); // Lưu lỗi
                                    await browser.close();
                                    break; // Thoát vòng lặp để chuyển qua profile khác
                                }
                            }

                            retryAttempts++;
                            if (retryAttempts >= maxRetries) {
                                console.log(`[${folderName}] [${proxyHost}] Đã thử ${maxRetries} lần mà không thấy iframe. Reload lại trang.`.bgYellow);
                                await reloadPage(folderName,proxyHost)
                                retryAttempts = 0;
                                reloadAttempts++;

                                if (reloadAttempts >= maxReloads) {
                                    console.log(`[${folderName}] [${proxyHost}] Đã reload ${maxReloads} lần mà không thấy iframe. Thoát.`.bgRed);
                                    logoutError.push(`Profile: ${folderName} - Không tìm thấy Iframe.`); // Lưu lỗi
                                    if (browser && browser.isConnected()) {
                                        await browser.close();
                                    }
                                    break; // Thoát vòng lặp
                                }
                            }
                        }
                    } catch (error) {
                        console.error(`[${folderName}] [${proxyHost}] Lỗi khi chờ iframe:`, error.message,'Reload lại trang. ');
                        try {
                            // Kiểm tra đăng xuất
                            const loginElement = await page.$('h1');
                            if (loginElement) {
                                const textContent = await page.evaluate(element => element.textContent, loginElement);
                                if (textContent.includes('Log in to Telegram by QR Code')) {
                                    console.log(`[${folderName}] [${proxyHost}] Đã đăng xuất khỏi Telegram. Chuyển qua profile khác.`.red);
                                    logoutError.push(`Profile: ${folderName} - Đã đăng xuất khỏi Telegram`); // Lưu lỗi
                                    await browser.close();
                                    break; // Thoát vòng lặp để chuyển qua profile khác
                                }
                            }

                        } catch (error) {
                            await reloadPage(folderName,proxyHost)
                        }
                        reloadAttempts++;
                        if (reloadAttempts >= maxReloads) {
                            console.log(`[${folderName}] [${proxyHost}] Đã reload ${maxReloads} lần mà không thấy iframe. Thoát.`.bgRed);
                            if (browser && browser.isConnected()) {
                                await browser.close();
                            }
                            break; // Thoát vòng lặp
                        }
                    }    
                } else {
                    console.error(`[${folderName}] [${proxyHost}] Lỗi khác xảy ra:`.bgRed, err);
                    logoutError.push(`Profile: ${folderName} - Lỗi: ${err.message}`); // Lưu lỗi
                    if (browser && browser.isConnected()) {
                        await browser.close();
                    }
                    break;
                }
            }
        }

    } catch (error) { 
        if (error.message.includes('Failed to launch the browser process')) {
            console.error(`[${folderName}] [${proxyHost}] Không thể khởi chạy trình duyệt:`, error.message);
        } else if (error.message.includes('net::ERR_INVALID_AUTH_CREDENTIALS')) {
            // Khi gặp lỗi "net::ERR_INVALID_AUTH_CREDENTIALS"
            console.error(`[${folderName}] [${proxyHost}] Lỗi xác thực proxy: ${error.message}`);
            
            // Lưu lại thông tin vào danh sách lỗi để chạy lại sau (nếu cần thiết)
            failedProfiles.push({ folderName, proxy });

            // Tắt mở lại trình duyệt và xóa xác thực proxy
            try {
                // Đóng trình duyệt hiện tại
                await browser.close();
                console.log(`[${folderName}] [${proxyHost}] Đã đóng trình duyệt vì lỗi xác thực proxy.`);
            } catch (closeError) {
                console.error(`[${folderName}] [${proxyHost}] Lỗi khi đóng trình duyệt: ${closeError.message}`);
            }

            // Tiến hành lại với việc mở trình duyệt mới và xác thực proxy lại
            try {
                const newBrowser = await retry(() => launchBrowser({
                    headless: head,
                    args: [
                        `--proxy-server=${proxyAuthURL}`,  // Cấu hình proxy
                        `--user-data-dir=${userDataPath}`, // Thư mục dữ liệu người dùng
                        '--disable-notifications',
                        '--disable-extensions',
                        '--no-sandbox',
                        '--disable-gpu',
                        '--window-size=800,800',
                        '--force-device-scale-factor=0.5'
                    ],
                    defaultViewport: { width: 800, height: 700 }
                }), 3);

                console.log(`[${folderName}] [${proxyHost}] Đã mở lại trình duyệt sau khi gặp lỗi xác thực proxy.`);

                // Mở lại trang mới hoặc tiếp tục với quy trình của bạn
                const page = await newBrowser.newPage();
                // Lấy danh sách tất cả cookies
                const cookies = await page.cookies();

                // Xóa tất cả cookies liên quan đến xác thực proxy (giả sử cookie xác thực có tên là 'proxy-auth-cookie')
                for (let cookie of cookies) {
                    // Kiểm tra và xóa các cookie liên quan đến xác thực proxy
                    if (cookie.name === 'proxy-auth-cookie' || cookie.domain === 'proxy.example.com') { // Thay đổi theo tên hoặc domain cookies proxy của bạn
                        await page.deleteCookie(cookie);
                        console.log(`[${folderName}] [${proxyHost}] Đã xóa cookie: ${cookie.name} với domain: ${cookie.domain}`);
                    }
                }
                // Xác thực lại proxy (nếu cần thiết)
                if (proxyUsername && proxyPassword) {
                    await page.authenticate({
                        username: proxyUsername,
                        password: proxyPassword
                    });
                    console.log(`[${folderName}] [${proxyHost}] Đã xác thực lại proxy: ${proxyUsername}@${proxyHost}`);
                }

                // Tiến hành điều hướng và xử lý các bước tiếp theo
                await page.goto(url, { waitUntil: 'load', timeout: 60000 });
            } catch (retryError) {
                console.error(`[${folderName}] [${proxyHost}] Lỗi khi mở lại trình duyệt:`, retryError.message);
                // Lưu vào danh sách lỗi để thực hiện lại sau nếu cần
                failedProfiles.push({ folderName, proxy });
            }
        } else {
            // Xử lý các lỗi khác
            console.error(`[${folderName}] [${proxyHost}] Lỗi không xác định:`, error.message);
        }
    }

};
async function retryFailedProfiles(failedProfiles,url, elementSelector,dataFilePath,theard,showBrowser) {
    if (failedProfiles.length > 0) {
        console.log(`Thử lại ${failedProfiles.length} profile gặp lỗi...`.bgMagenta);

        // Chạy lại các tác vụ với async.eachLimit để giới hạn số lượng tác vụ chạy đồng thời
        await new Promise((resolve, reject) => {
            async.eachLimit(failedProfiles, theard, async (profile) => {
                try {
                    // Xử lý lại mỗi profile bị lỗi
                    await processProfile(profile, { url, elementSelector, dataFilePath, showBrowser });
                    console.log(`[${profile.folderName}] [${profile.proxy}] Đã xử lý lại thành công`.blue);
                } catch (err) {
                    console.error(`[${profile.folderName}] [${profile.proxy}] Xử lý lại gặp lỗi: ${err.message}`);
                }
            }, (err) => {
                if (err) {
                    reject(err); // Nếu có lỗi trong khi xử lý, reject promise
                } else {
                    resolve(); // Nếu không có lỗi, resolve promise
                }
            });
        });
    } else {
        console.log('Không có profile nào để thử lại.');
    }
}

const run = async () => {
    try{
        const gameData = fs.readFileSync('ini/select_game.txt', 'utf-8').split('\n').map(line => line.trim()).filter(Boolean);

        if (gameData.length === 0) {
            console.error('Không có dữ liệu trong file select_game.txt');
            return;
        }

        const [nameTask, url, elementSelector, dataFilePath,theard,showBrowser] = gameData[0].split('|');
        //console.log('showBrowser: ',showBrowser)
        fs.writeFileSync(dataFilePath, '', 'utf-8'); // Xóa dữ liệu cũ
        const profiles = readProfilesFromFile();

        //MAX_PARALLEL_PROFILES = theard
        
        // Sử dụng async.eachLimit để giới hạn số lượng tác vụ chạy đồng thời
        await new Promise((resolve, reject) => {
            async.eachLimit(profiles, theard, async (profile) => {
                await processProfile(profile, { url, elementSelector, dataFilePath,showBrowser });
            }, (err) => {
                if (err) {
                    reject(err);
                } else {
                    resolve();
                }
            });
        });

        await retryFailedProfiles(failedProfiles,url, elementSelector, dataFilePath,theard,showBrowser); 

        if (logoutError.length > 0) {
            const bom = '\uFEFF'; // BOM cho UTF-8
            const dataWithTaskName = logoutError.map(line => `${nameTask}: ${line}`).join('\n'); // Thêm nameTask vào đầu mỗi dòng

            // Kiểm tra nếu tệp chưa tồn tại, thêm BOM
            fs.access('ini/LogOut.txt', fs.constants.F_OK, (err) => {
                const initialContent = err ? bom : ''; // Nếu tệp chưa tồn tại, thêm BOM
                const contentToAppend = initialContent + dataWithTaskName + '\n';

                // Ghi thêm dữ liệu vào file
                fs.appendFile('ini/LogOut.txt', contentToAppend, (err) => {
                    if (err) {
                        console.error('Lỗi khi ghi lỗi vào file:', err);
                    } else {
                        console.log('Đã ghi thêm lỗi vào file: ini/LogOut.txt');
                    }
                });
            });
        } else {
            console.log('Không có lỗi nào cần ghi ra file.');
        }

        console.log(`Hoàn thành ${countProfile} profile.`);
        await new Promise(resolve => setTimeout(resolve, 5000)); 
    }catch(error) {
        console.error(` Lỗi với": `, error.message);
        await new Promise(resolve => setTimeout(resolve, 5000)); 
    }
};

run();
